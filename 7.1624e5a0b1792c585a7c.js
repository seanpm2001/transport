(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{Fn1H:function(e,t,n){"use strict";n.r(t),n.d(t,"TypescriptModule",function(){return Q});var o=n("ofXK"),s=n("tyNb"),a=n("fXoL"),r=n("8MG2"),i=n("320Y"),c=n("jQpT");const b=["mainContent"];function l(e,t){1&e&&(a.Pb(0,"clr-vertical-nav-group-children"),a.Pb(1,"a",8),a.zc(2," Importing Transport (ES6) "),a.Ob(),a.Pb(3,"a",9),a.zc(4," Importing Transport (UMD) "),a.Ob(),a.Pb(5,"a",10),a.zc(6," Importing into Angular "),a.Ob(),a.Pb(7,"a",11),a.zc(8," Importing into React "),a.Ob(),a.Pb(9,"a",12),a.zc(10," Initializing Transport "),a.Ob(),a.Pb(11,"a",13),a.zc(12," Hello World! "),a.Ob(),a.Ob())}function h(e,t){1&e&&(a.Pb(0,"clr-vertical-nav-group-children"),a.Pb(1,"a",14),a.zc(2," Overview "),a.Ob(),a.Pb(3,"a",15),a.zc(4," Connecting to a Broker "),a.Ob(),a.Pb(5,"a",16),a.zc(6," Connecting Multiple Brokers "),a.Ob(),a.Pb(7,"a",17),a.zc(8," Extending Channels "),a.Ob(),a.Ob())}function p(e,t){1&e&&(a.Pb(0,"clr-vertical-nav-group-children"),a.Pb(1,"a",18),a.zc(2," Building Services "),a.Ob(),a.Pb(3,"a",19),a.zc(4," Calling Services "),a.Ob(),a.Pb(5,"a",20),a.zc(6," Advanced Messaging "),a.Ob(),a.Pb(7,"a",21),a.zc(8," Transactions "),a.Ob(),a.Pb(9,"a",22),a.zc(10," Logging "),a.Ob(),a.Ob())}function d(e,t){1&e&&(a.Pb(0,"clr-vertical-nav-group-children"),a.Pb(1,"a",23),a.zc(2," Stores: Basics "),a.Ob(),a.Pb(3,"a",24),a.zc(4," Stores: Advanced "),a.Ob(),a.Ob())}function u(e,t){1&e&&(a.Pb(0,"clr-vertical-nav-group-children"),a.Pb(1,"a",25),a.zc(2," Messaging Across iFrames "),a.Ob(),a.Pb(3,"a",26),a.zc(4," Built in Abstractions "),a.Ob(),a.Ob())}let g=(()=>{class e{constructor(){}ngOnInit(){}onActivate(e){this.mainContentDiv&&(this.mainContentDiv.nativeElement.scrollTop=0)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-typescript"]],viewQuery:function(e,t){if(1&e&&a.Fc(b,!0),2&e){let e;a.lc(e=a.Yb())&&(t.mainContentDiv=e.first)}},decls:25,vars:7,consts:[[1,"content-container"],[3,"clrVerticalNavCollapsible","clr-nav-level"],["clrVerticalNavLink","","routerLink","./overview","routerLinkActive","active"],["routerLinkActive","active"],[4,"clrIfExpanded"],["id","main-content",1,"content-area"],["mainContent",""],[3,"activate"],["clrVerticalNavLink","","routerLink","./importing","routerLinkActive","active"],["clrVerticalNavLink","","routerLink","./importing-umd","routerLinkActive","active"],["clrVerticalNavLink","","routerLink","./importing-angular","routerLinkActive","active"],["clrVerticalNavLink","","routerLink","./importing-react","routerLinkActive","active"],["clrVerticalNavLink","","routerLink","./initializing","routerLinkActive","active"],["clrVerticalNavLink","","routerLink","./hello-world","routerLinkActive","active"],["clrVerticalNavLink","","routerLink","./broker-overview","routerLinkActive","active"],["clrVerticalNavLink","","routerLink","./connecting-broker","routerLinkActive","active"],["clrVerticalNavLink","","routerLink","./multiple-brokers","routerLinkActive","active"],["clrVerticalNavLink","","routerLink","./extending-channels","routerLinkActive","active"],["clrVerticalNavLink","","routerLink","./building-services","routerLinkActive","active"],["clrVerticalNavLink","","routerLink","./calling-services","routerLinkActive","active"],["clrVerticalNavLink","","routerLink","./advanced-messaging","routerLinkActive","active"],["clrVerticalNavLink","","routerLink","./transactions","routerLinkActive","active"],["clrVerticalNavLink","","routerLink","./logging","routerLinkActive","active"],["clrVerticalNavLink","","routerLink","./store-basics","routerLinkActive","active"],["clrVerticalNavLink","","routerLink","./store-advanced","routerLinkActive","active"],["clrVerticalNavLink","","routerLink","./iframes","routerLinkActive","active"],["clrVerticalNavLink","","routerLink","./abstractions","routerLinkActive","active"]],template:function(e,t){1&e&&(a.Pb(0,"clr-main-container"),a.Kb(1,"transport-header"),a.Pb(2,"div",0),a.Pb(3,"clr-vertical-nav",1),a.Pb(4,"a",2),a.zc(5," TypeScript Overview "),a.Ob(),a.Pb(6,"clr-vertical-nav-group",3),a.zc(7," Getting Started "),a.xc(8,l,13,0,"clr-vertical-nav-group-children",4),a.Ob(),a.Pb(9,"clr-vertical-nav-group",3),a.zc(10," Extending To Brokers "),a.xc(11,h,9,0,"clr-vertical-nav-group-children",4),a.Ob(),a.Pb(12,"clr-vertical-nav-group",3),a.zc(13," Operations "),a.xc(14,p,11,0,"clr-vertical-nav-group-children",4),a.Ob(),a.Pb(15,"clr-vertical-nav-group",3),a.zc(16," Using Stores "),a.xc(17,d,5,0,"clr-vertical-nav-group-children",4),a.Ob(),a.Pb(18,"clr-vertical-nav-group",3),a.zc(19," Utilities "),a.xc(20,u,5,0,"clr-vertical-nav-group-children",4),a.Ob(),a.Ob(),a.Pb(21,"div",5,6),a.Pb(23,"router-outlet",7),a.Xb("activate",function(e){return t.onActivate(e)}),a.Ob(),a.Ob(),a.Ob(),a.Kb(24,"transport-footer"),a.Ob()),2&e&&(a.wb(3),a.gc("clrVerticalNavCollapsible",!1)("clr-nav-level",2),a.wb(5),a.gc("clrIfExpanded",!0),a.wb(3),a.gc("clrIfExpanded",!0),a.wb(3),a.gc("clrIfExpanded",!0),a.wb(3),a.gc("clrIfExpanded",!0),a.wb(3),a.gc("clrIfExpanded",!0))},directives:[r.f,r.p,i.a,r.l,r.g,s.b,r.o,s.a,r.m,r.s,r.e,s.d,c.a,r.n],styles:[".content-area[_ngcontent-%COMP%]{padding:20px}"]}),e})();var m=n("w7eE"),P=n("QOlJ"),z=n("SrJx"),O=n("CyPm");function y(e,t){if(1&e&&(a.Pb(0,"section"),a.Pb(1,"h4",4),a.zc(2),a.Ob(),a.Kb(3,"transport-animated-console",5),a.Ob()),2&e){const e=t.$implicit,n=t.index;a.wb(2),a.Ac(e.title),a.wb(1),a.gc("inputCommand",e.command)("helperTxt",e.notes)("consoleTheme","macOS")("loopAnimation",!1)("delay",1e3*n)}}let f=(()=>{class e extends m.a{constructor(e){super("OverviewComponent"),this.highlightService=e,this.highlighted=!1}highlight(){this.highlightService.highlightAll()}ngOnInit(){this.tsCommands=P.c}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(t){return new(t||e)(a.Ib(z.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-ts-overview"]],features:[a.tb],decls:20,vars:1,consts:[["src","assets/github.png","alt","github","title","transport on github",1,"github-logo"],["href","https://github.com/vmware/transport-typescript"],[4,"ngFor","ngForOf"],["routerLink","/ts/importing",1,"btn","btn-primary","btn-block","btn-outline"],[1,"code-step"],[3,"inputCommand","helperTxt","consoleTheme","loopAnimation","delay"]],template:function(e,t){1&e&&(a.Pb(0,"h1"),a.zc(1,"Transport for TypeScript"),a.Ob(),a.Kb(2,"img",0),a.Pb(3,"a",1),a.zc(4,"View TypeScript source on Github"),a.Ob(),a.Pb(5,"p"),a.zc(6," This implementation is designed to operate in the Browser (for right now anyway). However it is "),a.Pb(7,"strong"),a.zc(8,"framework agnostic"),a.Ob(),a.zc(9,", and will work along-side any UI framework you want to implement.\n"),a.Ob(),a.Pb(10,"p"),a.zc(11," Transport does not care which framework you would like to run. It's directly accessible from the "),a.Pb(12,"code"),a.zc(13,"window"),a.Ob(),a.zc(14," object, if you don't even want to use a framework. We're using examples from Angular and React in places, however the same principals would apply in any framework.\n"),a.Ob(),a.xc(15,y,4,6,"section",2),a.Kb(16,"hr"),a.Pb(17,"a",3),a.zc(18,"Next Steps: Importing Transport"),a.Ob(),a.Kb(19,"hr")),2&e&&(a.wb(15),a.gc("ngForOf",t.tsCommands))},directives:[o.m,s.b,O.a],styles:[""]}),e})(),v=(()=>{class e{constructor(e){this.highlightService=e,this.highlighted=!1}ngOnInit(){}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(t){return new(t||e)(a.Ib(z.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-importing"]],decls:37,vars:4,consts:[[3,"inputCommand","consoleTheme","loopAnimation","disableAnimation"],[1,"clr-code"],[1,"code"],[1,"language-js"],["href","https://stackblitz.com/edit/js-kduy8v?file=index.js"],["src",a.Ec("https://stackblitz.com/edit/js-kduy8v?file=index.js&ctl=1&embed=1"),1,"stackblitz"],[1,"language-typescript"],["routerLink","/ts/initializing",1,"btn","btn-primary","btn-block","btn-outline"]],template:function(e,t){1&e&&(a.Pb(0,"h1"),a.zc(1,"Importing Transport for TypeScript via ES6 Module"),a.Ob(),a.Pb(2,"p"),a.zc(3," Make sure you install transport first, Package is available via npm.\n"),a.Ob(),a.Kb(4,"br"),a.Kb(5,"transport-animated-console",0),a.Kb(6,"hr"),a.Pb(7,"h2"),a.zc(8,"ES6 Module Import (recommended)"),a.Ob(),a.Pb(9,"p"),a.zc(10," This is way we recommend you import Transport. It allows build management tools such as Webpack to tree-shake unused exports of the library. This in turn shaving off some bits and reduces overall size of your application.\n"),a.Ob(),a.Pb(11,"p"),a.zc(12," To import and initialize Transport, simply call "),a.Pb(13,"code",1),a.zc(14,"BusUtil.bootBus()"),a.Ob(),a.zc(15," as follows:\n"),a.Ob(),a.Pb(16,"pre",2),a.Pb(17,"code",3),a.Jb(),a.zc(18,"import { BusUtil } from '@vmw/transport/util/bus.util';\n\n// boot the event bus!\nBusUtil.bootBus();\n\n// create a reference to the bus\nconst bus = BusUtil.getBusInstance();\n\n// now do something interesting.\n...\n"),a.Qb(),a.Ob(),a.Ob(),a.Pb(19,"h4"),a.Pb(20,"a",4),a.zc(21,"Try it out in StackBlitz"),a.Ob(),a.Ob(),a.Kb(22,"iframe",5),a.Kb(23,"hr"),a.Pb(24,"h2"),a.zc(25,"Importing Transport in your code"),a.Ob(),a.Pb(26,"p"),a.zc(27," The main interface you will need is "),a.Pb(28,"code",1),a.zc(29,"EventBus"),a.Ob(),a.zc(30,". It provides access to the most common methods.\n"),a.Ob(),a.Pb(31,"pre",2),a.Pb(32,"code",6),a.Jb(),a.zc(33," import { EventBus } from '@vmw/transport';"),a.Qb(),a.Ob(),a.Ob(),a.Kb(34,"hr"),a.Pb(35,"a",7),a.zc(36,"Next Steps: Initializing Transport"),a.Ob()),2&e&&(a.wb(5),a.gc("inputCommand","npm install @vmw/transport --save")("consoleTheme","macOS")("loopAnimation",!1)("disableAnimation",!0))},directives:[O.a,s.b],styles:[""]}),e})(),w=(()=>{class e{constructor(e){this.highlightService=e,this.highlighted=!1}ngOnInit(){}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(t){return new(t||e)(a.Ib(z.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-initializing"]],decls:73,vars:0,consts:[["id","initializing"],[1,"clr-code"],[1,"orange"],[1,"code"],[1,"language-typescript"],[1,"clr-row"],[1,"clr-col-lg-6"],[1,"card"],[1,"card-header"],[1,"card-block"],[1,"card-text"],["routerLink","../abstractions"],["href","https://github.com/vmware/transport-typescript/blob/master/src/util/bus.util.ts","target","_blank"],["routerLink","/ts/hello-world",1,"btn","btn-primary","btn-block","btn-outline"]],template:function(e,t){1&e&&(a.Pb(0,"h1",0),a.zc(1," Initializing Transport\n"),a.Ob(),a.Pb(2,"p"),a.zc(3," Transport operates outside of any vendor UI technology framework. It's completely decoupled, allowing it to be used by any framework. Because it's independent, it needs to be initialized before any other frameworks have booted or started e.g. Angular.\n"),a.Ob(),a.Pb(4,"p"),a.zc(5," There are a couple of ways to do this, the first is to create an initialization script that is auto-loaded into the "),a.Pb(6,"code",1),a.zc(7,"<head/>"),a.Ob(),a.zc(8," of the DOM and would therefore boot before the UI framework does. This init/boot script serves as a great spot to set up and configure all your fabric needs.\n"),a.Ob(),a.Pb(9,"h3"),a.zc(10,"Booting via init script"),a.Ob(),a.Pb(11,"p"),a.zc(12," The simplest and quickest way to initialize the bus is in this init script, you just need a single line of code.\n"),a.Ob(),a.Pb(13,"h4",2),a.zc(14,"Simplest Way"),a.Ob(),a.Pb(15,"pre",3),a.Pb(16,"code",4),a.Jb(),a.zc(17,"import { BusUtil } from '@vmw/transport/util/bus.util';\n\n// initializing transport (event bus)\nconst bus = BusUtil.bootBus();\n"),a.Qb(),a.Ob(),a.Ob(),a.Pb(18,"h4",2),a.zc(19,"Using Options"),a.Ob(),a.Pb(20,"pre",3),a.Pb(21,"code",4),a.Jb(),a.zc(22,"import { BusUtil } from '@vmw/transport/util/bus.util';\n\n// initializing transport, with debug logging enabled, and the boot message is not disabled.\nconst bus = BusUtil.bootBusWithOptions(LogLevel.Debug, false);\n"),a.Qb(),a.Ob(),a.Ob(),a.Pb(23,"p"),a.zc(24," Transport is now active and ready to be be used. It operates as a singleton inside your application. You don't need to hold on to your reference here, the bus is attached to the "),a.Pb(25,"code",1),a.zc(26,"window"),a.Ob(),a.zc(27," object and won't be lost.\n"),a.Ob(),a.Kb(28,"hr"),a.Pb(29,"h2"),a.zc(30," Access to Transport in your app.\n"),a.Ob(),a.Pb(31,"p"),a.zc(32," There are two main ways to gain access to the singleton instance of transport in your app.\n"),a.Ob(),a.Pb(33,"div",5),a.Pb(34,"div",6),a.Pb(35,"div",7),a.Pb(36,"div",8),a.zc(37," Using "),a.Pb(38,"code",1),a.zc(39,"window.AppEventBus"),a.Ob(),a.Ob(),a.Pb(40,"div",9),a.Pb(41,"div",10),a.zc(42," Transport is added to your "),a.Pb(43,"code",1),a.zc(44,"window"),a.Ob(),a.zc(45," object under the property "),a.Pb(46,"code",1),a.zc(47,"AppEventBus"),a.Ob(),a.zc(48,". "),a.Kb(49,"br"),a.zc(50," This is most useful for non-TypeScript applications. Applications using vanilla JavaScript would use this method. "),a.Ob(),a.Ob(),a.Ob(),a.Ob(),a.Pb(51,"div",6),a.Pb(52,"div",7),a.Pb(53,"div",8),a.zc(54," Using built in "),a.Pb(55,"a",11),a.zc(56,"Abstract Classes"),a.Ob(),a.Ob(),a.Pb(57,"div",9),a.Pb(58,"div",10),a.zc(59," We created a few simple "),a.Pb(60,"a",11),a.zc(61,"abstract base classes"),a.Ob(),a.zc(62," that prepare everything for you. This is the easiest and cleanest way if you're using TypeScript. "),a.Ob(),a.Ob(),a.Ob(),a.Ob(),a.Ob(),a.Pb(63,"p"),a.zc(64," You can find out about some of the other methods available by looking at the "),a.Pb(65,"code",1),a.zc(66,"BusUtil"),a.Ob(),a.zc(67," API, you can find the code here: "),a.Pb(68,"a",12),a.zc(69,"https://github.com/vmware/transport-typescript/blob/master/src/util/bus.util.ts"),a.Ob(),a.Ob(),a.Kb(70,"hr"),a.Pb(71,"a",13),a.zc(72,"Next Steps: Hello World"),a.Ob())},directives:[s.b],styles:[""]}),e})();var k=n("/bWC");let S=(()=>{class e extends k.a{constructor(e){super("HelloWorldComponent"),this.highlightService=e,this.highlighted=!1}ngOnInit(){}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(t){return new(t||e)(a.Ib(z.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-hello-world"]],features:[a.tb],decls:61,vars:0,consts:[[1,"code"],[1,"language-typescript"],["href","https://stackblitz.com/edit/angular-hbyhd5"],["src",a.Ec("https://stackblitz.com/edit/angular-hbyhd5?ctl=1&embed=1&file=src/app/hello-world.component.ts"),1,"stackblitz"],[1,"clr-code"],["href","https://stackblitz.com/edit/react-ts-vxv7zh"],["src",a.Ec("https://stackblitz.com/edit/react-ts-vxv7zh?ctl=1&embed=1&file=HelloWorld.tsx"),1,"stackblitz"],["role","alert",1,"alert","alert-success"],[1,"alert-items"],[1,"alert-item","static"],[1,"alert-icon-wrapper"],["shape","exclamation-circle",1,"alert-icon"],[1,"alert-text"],["routerLink","/ts/broker-overview",1,"btn","btn-primary","btn-block","btn-outline"]],template:function(e,t){1&e&&(a.Pb(0,"h1"),a.zc(1,"Hello World in TypeScript"),a.Ob(),a.Pb(2,"p"),a.zc(3," To demonstrate the simplest possible use of the event bus, we will create a simple component that simply talks to its self.\n"),a.Ob(),a.Pb(4,"h3"),a.zc(5,"Angular Example"),a.Ob(),a.Pb(6,"pre",0),a.Pb(7,"code",1),a.Jb(),a.zc(8,"import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractBase } from '@vmw/transport/core';\n\n@Component({\n    selector: 'hello-world',\n    template: `\n    <h1>Transport: Hello World Angular</h1>\n    <p>\n      Sending Ping (to myself):\n    </p>\n    <hr />\n    <p>\n      Ping:\n      <strong><code>{{ ping }}</code></strong>\n    </p>\n    <p>\n      Pong:\n      <strong><code>{{ pong }}</code></strong>\n    </p>\n  `,\n    styles: []\n})\nexport class HelloWorldComponent extends AbstractBase implements OnInit {\n    @Input() ping: string;\n    public pong: string;\n\n    // define a channel to talk on.\n    private myChannel = 'some-channel';\n\n    constructor() {\n        super('HelloWorldComponent');\n    }\n\n    ngOnInit(): void {\n        // listen for requests on 'myChannel' and return a response.\n        this.bus.respondOnce(this.myChannel)\n            .generate((request: string) => {\n                return 'Message received! ' + request;\n            });\n\n        // send request 'hello' on channel 'myChannel'.\n        this.bus.requestOnce(this.myChannel, this.ping)\n            .handle((response: string) => {\n                this.pong = response;\n            });\n    }\n}\n"),a.Qb(),a.Ob(),a.Ob(),a.Pb(9,"h4"),a.Pb(10,"a",2),a.zc(11,"Try it out in StackBlitz"),a.Ob(),a.Ob(),a.Kb(12,"iframe",3),a.Kb(13,"hr"),a.Pb(14,"h3"),a.zc(15,"React Example"),a.Ob(),a.Pb(16,"p"),a.zc(17," There are multiple ways to use transport inside of any UI framework, so to keep things simple, we have created a small but useful React Component superclass that makes the bus available easily.\n"),a.Ob(),a.Pb(18,"pre",0),a.Pb(19,"code",1),a.Jb(),a.zc(20,"import { EventBus } from '@vmw/transport/bus.api';\nimport { BusUtil } from '@vmw/transport/util';\nimport React from 'react';\n\nexport abstract class BaseComponent<A, S> extends React.Component<A, S> {\n    public bus: EventBus = BusUtil.getBusInstance();\n    constructor(props: A) {\n    super();\n  }\n}\n\n/* Define application state and props */\ninterface AppProps  {\n    ping: string;\n }\ninterface AppState  {\n    pong: string;\n}"),a.Qb(),a.Ob(),a.Ob(),a.Pb(21,"p"),a.zc(22," Now that we have that little superclass there, we can go ahead and create the "),a.Pb(23,"code",4),a.zc(24,"HelloWorld"),a.Ob(),a.Ob(),a.Pb(25,"pre",0),a.Pb(26,"code",1),a.Jb(),a.zc(27,"\nimport { BaseComponent } from './BaseComponent';\nimport React from 'react';\n\nexport default class HelloWorld extends BaseComponent<AppProps, AppState> {\n    // define a channel to talk on.\n    private myChannel = 'some-channel';\n\n    constructor(props: AppProps) {\n        super(props);\n        this.state = {\n            ping: props.ping,\n            pong: 'no response'\n        };\n    }\n\n    componentDidMount() {\n        // listen for requests on 'myChannel' and return a response.\n        this.bus.respondOnce(this.myChannel).generate((request: string) => {\n            return 'Message received! ' + request;\n        });\n\n        // send request 'hello' on channel 'myChannel'.\n        this.bus.requestOnce(this.myChannel, this.props.ping)\n          .handle((response: string) => {\n\n            // set state.\n            this.setState({ pong: response });\n          });\n    }\n\n    render() {\n        return (\n          <div>\n            <h1>Transport: Hello World React</h1>\n              <p>Sending Ping (to myself):</p>\n              <hr />\n            <p>\n              Ping:\xa0\n              <strong>\n                <code>{this.state.ping}</code>\n              </strong>\n            </p>\n            <p>\n              Pong:\xa0\n              <strong>\n                <code>{this.state.pong}</code>\n            </strong>\n            </p>\n          </div>\n        );\n  }\n}\n"),a.Qb(),a.Ob(),a.zc(28,"\n"),a.Ob(),a.Pb(29,"h4"),a.Pb(30,"a",5),a.zc(31,"Try it out in StackBlitz"),a.Ob(),a.Ob(),a.Kb(32,"iframe",6),a.Pb(33,"p"),a.zc(34," In the above examples, we set up a simple lambda to handle an inbound message (request). This responder uses the "),a.Pb(35,"code",4),a.zc(36,"respondOnce()"),a.Ob(),a.zc(37," method to listen for a single request, this method returns an object of type "),a.Pb(38,"code",4),a.zc(39,"MessageResponder<string>"),a.Ob(),a.zc(40,". Responders generate responses by using the "),a.Pb(41,"code",4),a.zc(42,"generate()"),a.Ob(),a.zc(43," method. You simply pass in a lambda that accepts a request argument (in the case of this example "),a.Pb(44,"code",4),a.zc(45,"request: string"),a.Ob(),a.zc(46,"), and returns a response (in this example "),a.Pb(47,"code",4),a.zc(48,"'world'"),a.Ob(),a.zc(49,").\n"),a.Ob(),a.Kb(50,"hr"),a.Pb(51,"div",7),a.Pb(52,"div",8),a.Pb(53,"div",9),a.Pb(54,"div",10),a.Kb(55,"clr-icon",11),a.Ob(),a.Pb(56,"span",12),a.zc(57," That's basically it. There are tons more features, however you can essentially locate your sender and receivers in any component, anywhere in your application and this will work. This is the value of transport, you can 'jump' anything, any-where, to any-point in your application. "),a.Ob(),a.Ob(),a.Ob(),a.Ob(),a.Kb(58,"hr"),a.Pb(59,"a",13),a.zc(60,"Next Steps: Broker Overview"),a.Ob())},directives:[r.d,r.b,s.b],styles:[""]}),e})(),T=(()=>{class e extends k.a{constructor(e){super("BuildingServicesComponent"),this.highlightService=e,this.highlighted=!1}ngOnInit(){}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(t){return new(t||e)(a.Ib(z.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-building-services"]],features:[a.tb],decls:141,vars:0,consts:[[1,"clr-code"],[1,"code"],[1,"language-typescript"],["id","loadingservice"],[1,"log-output"],[1,"console-purple"],[1,"console-pink"],[1,"console-who"],[1,"console-time"],["routerLink","/ts/calling-services",1,"btn","btn-primary","btn-block","btn-outline"]],template:function(e,t){1&e&&(a.Pb(0,"h1"),a.zc(1,"Building Message Based Services"),a.Ob(),a.Pb(2,"p"),a.zc(3," You're free to build applications however you want, however this is a pattern we use frequently. We combine this pattern with auto-generation, so that we don't need to build this code out each time - it's driven by OpenAPI specifications (if API driven).\n"),a.Ob(),a.Kb(4,"hr"),a.Pb(5,"h3"),a.zc(6,"Using "),a.Pb(7,"code",0),a.zc(8,"AbstractService"),a.Ob(),a.Ob(),a.Pb(9,"h3"),a.zc(10,"Example "),a.Ob(),a.Pb(11,"p"),a.zc(12," To get started, we should create a new class called "),a.Pb(13,"code",0),a.zc(14,"PongService"),a.Ob(),a.zc(15," in a folder named "),a.Pb(16,"code",0),a.zc(17,"services"),a.Ob(),a.zc(18," that sits off the root of your "),a.Pb(19,"code",0),a.zc(20,"src/"),a.Ob(),a.zc(21," folder. Your path should be "),a.Pb(22,"code",0),a.zc(23,"~/my-app-folder/src/services"),a.Ob(),a.Ob(),a.Pb(24,"p"),a.zc(25," The first thing we need to do in order to create our first simple "),a.Pb(26,"code",0),a.zc(27,"PongService"),a.Ob(),a.zc(28," is create a "),a.Pb(29,"code",0),a.zc(30,"PongServiceRequest"),a.Ob(),a.zc(31," model and a "),a.Pb(32,"code",0),a.zc(33,"PongServiceResponse"),a.Ob(),a.zc(34," model. These two models are responsible for allowing other actors to know what to send to our service, and what to expect in response.\n"),a.Ob(),a.Pb(35,"p"),a.zc(36," In the "),a.Pb(37,"code",0),a.zc(38,"services/"),a.Ob(),a.zc(39," folder, we will create a new file called "),a.Pb(40,"code",0),a.zc(41,"pong.service.model.ts"),a.Ob(),a.zc(42,". This is our request/response model that defines what our "),a.Pb(43,"code",0),a.zc(44,"PongService"),a.Ob(),a.zc(45," listens for and responds with.\n"),a.Ob(),a.Pb(46,"h3"),a.zc(47,"Create Service Request/Response Models."),a.Ob(),a.Pb(48,"pre",1),a.Pb(49,"code",2),a.Jb(),a.zc(50,"import { ChannelName } from '@vmw/transport';\nimport { AbstractMessageObject } from '@vmw/transport/core';\n\nexport const PongServiceChannel: ChannelName = 'services-PongService';\n\nexport enum PongRequestType {\n    Basic = 'Basic',\n    Full = 'Full'\n}\n\nexport interface PongServiceRequest extends AbstractMessageObject<PongRequestType, string> {\n    request: PongRequestType;\n    payload: string;\n}\n\nexport interface PongServiceResponse extends AbstractMessageObject<PongRequestType, string> {\n    payload: string;\n}"),a.Qb(),a.Ob(),a.Ob(),a.Pb(51,"p"),a.zc(52," Pretty simple right? We have defined a channel on which to talk, an enum to define the command we want to send and then two simple interfaces that define request and responses. You're not restricted to interfaces here, you can also use classes. The important thing to remember here is that this is "),a.Pb(53,"strong"),a.zc(54,"*ALL*"),a.Ob(),a.zc(55," that is required in order to talk to our new "),a.Pb(56,"code",0),a.zc(57,"PongService"),a.Ob(),a.zc(58,".\n"),a.Ob(),a.Pb(59,"p"),a.zc(60," The reason why we extend from "),a.Pb(61,"code",0),a.zc(62,"AbstractMessageObject"),a.Ob(),a.zc(63," is because is provides some important properties that we will need when making Fabric calls across the distributed bus.\n"),a.Ob(),a.Pb(64,"p"),a.zc(65," Next, lets create our actual "),a.Pb(66,"code",0),a.zc(67,"PongService"),a.Ob(),a.zc(68,". It looks like this:\n"),a.Ob(),a.Kb(69,"hr"),a.Pb(70,"h3"),a.zc(71,"PongService"),a.Ob(),a.Pb(72,"pre",1),a.Pb(73,"code",2),a.Jb(),a.zc(74,"import { AbstractService } from '@vmw/transport/core';\nimport { EventBus, MessageArgs } from '@vmw/transport';\nimport {\n    PongRequestType,\n    PongServiceChannel,\n    PongServiceRequest,\n    PongServiceResponse\n} from './pong.service.model';\n\nexport class PongService extends AbstractService<PongServiceRequest, PongServiceResponse> {\n\n    constructor() {\n\n        // identify the name of this service, and the channel it operates on.\n        super('PongService', PongServiceChannel);\n\n        // log that the service is online (if logging enabled)\n        this.log.info('PongService Loaded');\n    }\n\n    /**\n     * Handle a request send on the service channel.\n     * @param serviceRequest the request object\n     * @param args automatically passed by superclass, important details within.\n     */\n    protected handleServiceRequest(serviceRequest: PongServiceRequest, args?: MessageArgs): void {\n\n        switch (serviceRequest.request) {\n            case PongRequestType.Basic:\n                this.handleBasicRequest(request.payload, args);\n                break;\n\n            case PongRequestType.Full:\n                this.handleFullRequest(request.payload, args);\n                break;\n        }\n    }\n\n    /**\n     * Handle a basic request (limited details)\n     * @param message this is the message sent by the requesting actor.\n     * @param args these are important values that identify who sent the request.\n     */\n    private handleBasicRequest(message: string, args: MessageArgs): void {\n\n        const basicResponse = {\n            value: `pong '${message}'`\n        };\n\n        // send a response to whomever requested it.\n        this.postResponse(PongServiceChannel, basicResponse, args);\n    }\n\n    /**\n     * Handle a more detailed response (more details)\n     * @param message this is the message sent by the requesting actor.\n     * @param args these are important values that identify who sent the request.\n     */\n    private handleFullRequest(message: string, args: MessageArgs): void {\n\n        // get a timestamp.\n        const date = new Date();\n        const dateString = date.toLocaleDateString('en-US');\n        const perf = performance.now();\n\n        const basicResponse = {\n            value: `pong '${message}' (on ${date} by event bus with id ${EventBus.id}) time: ${perf}`\n        };\n\n        // send a response to whomever requested it.\n        this.postResponse(PongServiceChannel, basicResponse, args);\n\n    }\n}"),a.Qb(),a.Ob(),a.Ob(),a.Pb(75,"p"),a.zc(76," Now we can load "),a.Pb(77,"code",0),a.zc(78,"PongService"),a.Ob(),a.zc(79," whenever we like.\n"),a.Ob(),a.Kb(80,"hr"),a.Pb(81,"h3",3),a.zc(82,"Loading Services"),a.Ob(),a.Pb(83,"p"),a.zc(84," To load a service you can use the in-built static "),a.Pb(85,"code",0),a.zc(86,"ServiceLoader"),a.Ob(),a.zc(87," utility. The "),a.Pb(88,"code",0),a.zc(89,"ServiceLoader"),a.Ob(),a.zc(90," takes the service class type as the first argument, and then as many other constructor properties as you need for your service (variable args). In this example, we could load our service at the same time we boot the bus (i.e. before Angular even loads).\n"),a.Ob(),a.Pb(91,"p"),a.zc(92," We could also load the service on demand when it's required, by loading the service as a part of a module definition. It's really up to you. The general rule is that a global service, should be ready before your application boots, other services can be booted on demand.\n"),a.Ob(),a.Pb(93,"p"),a.zc(94," How do I boot "),a.Pb(95,"code",0),a.zc(96,"PongService"),a.Ob(),a.zc(97,"? Easy. Just pass your class to "),a.Pb(98,"code",0),a.zc(99,"ServiceLoader"),a.Ob(),a.zc(100,". Just like this:\n"),a.Ob(),a.Pb(101,"h3"),a.zc(102,"Using ServiceLoader"),a.Ob(),a.Pb(103,"pre",1),a.Pb(104,"code",2),a.Jb(),a.zc(105,"import { ServiceLoader } from '@vmw/transport/util/service.loader';\n\nServiceLoader.addService(PongService);"),a.Qb(),a.Ob(),a.Ob(),a.Pb(106,"p"),a.zc(107," If you want to create a service that accepts constructor arguments, and you want to pass them to the service loader? You can just add your constructor args to the "),a.Pb(108,"code",0),a.zc(109,"AddService"),a.Ob(),a.zc(110," method.\n"),a.Ob(),a.Pb(111,"h3"),a.zc(112,"Using ServiceLoader with constructor args"),a.Ob(),a.Pb(113,"pre",1),a.Pb(114,"code",2),a.Jb(),a.zc(115,"...\n    constructor(arg1, arg2, arg3) {\n...\n\nServiceLoader.addService(PongService, arg1, arg2, arg3);"),a.Qb(),a.Ob(),a.Ob(),a.Pb(116,"p"),a.zc(117," Once the service has loaded, you should see some output in the developer console, that looks something like...\n"),a.Ob(),a.Pb(118,"pre",4),a.zc(119,"\u25ab\ufe0f\ufe0f"),a.Pb(120,"span",5),a.zc(121,"[Inf]:"),a.Ob(),a.zc(122," \ud83c\udf0e "),a.Pb(123,"span",6),a.zc(124,"Service Adaptor: PongService (3e4f3014) online and listening on 'services::PongService'"),a.Ob(),a.zc(125," "),a.Pb(126,"span",7),a.zc(127,"[PongService]"),a.Ob(),a.zc(128," "),a.Pb(129,"span",8),a.zc(130,"(9:25:39 AM)"),a.Ob(),a.zc(131,"\n\u25ab\ufe0f\ufe0f"),a.Pb(132,"span",5),a.zc(133,"[Inf]:"),a.Ob(),a.zc(134," "),a.Pb(135,"span",6),a.zc(136,"PongService Loaded"),a.Ob(),a.zc(137,"\n"),a.Ob(),a.Kb(138,"hr"),a.Pb(139,"a",9),a.zc(140,"Next Steps: Calling Services"),a.Ob())},directives:[s.b],styles:[""]}),e})(),C=(()=>{class e extends k.a{constructor(e){super("CallingServicesComponent"),this.highlightService=e,this.highlighted=!1}ngOnInit(){}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(t){return new(t||e)(a.Ib(z.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-calling-services"]],features:[a.tb],decls:89,vars:0,consts:[[1,"clr-code"],[1,"code"],[1,"language-typescript"],["href","https://github.com/vmware/transport-typescript/blob/master/src/bus.api.ts","target","_blank"],["routerLink","/ts/advanced-messaging",1,"btn","btn-primary","btn-block","btn-outline"]],template:function(e,t){1&e&&(a.Pb(0,"h1"),a.zc(1,"Calling Message Based Services."),a.Ob(),a.Pb(2,"p"),a.zc(3," In order to call "),a.Pb(4,"code",0),a.zc(5,"PongService"),a.Ob(),a.zc(6," from a component, we just need to make a request over the "),a.Pb(7,"code",0),a.zc(8,"PongService"),a.Ob(),a.zc(9," channel and handle the response. In this example, we're going to use a 'broadcast' mechanism. This is explained in more detail below, but in a nutshell - it means that it's an open conversation between the component and the service.\n"),a.Ob(),a.Pb(10,"p"),a.zc(11," This means any other component listening for responses on "),a.Pb(12,"code",0),a.zc(13,"PongService"),a.Ob(),a.zc(14," would also receive that response. This can be useful if you want a bunch of different components to update, every time a request for a list of something is requested (however it would be a better design to use the store for this usecase).\n"),a.Ob(),a.Pb(15,"p"),a.zc(16,"Lets create a simple component called "),a.Pb(17,"code",0),a.zc(18,"PingComponent"),a.Ob(),a.Ob(),a.Pb(19,"h3"),a.zc(20,"Angular PingComponent"),a.Ob(),a.Pb(21,"pre",1),a.Pb(22,"code",2),a.Jb(),a.zc(23,"import { AbstractBase } from '@vmw/transport/core';\nimport { Component } from '@angular/core';\nimport { PongRequestType, PongServiceChannel, PongServiceRequest, PongServiceResponse } from './pong.service.model';\nimport { GeneralUtil } from '@vmw/transport/util/util';\n\n@Component({\n    selector: 'ping-component',\n    template: `\n        <button (click)=\"sendPingBasic()\">Ping (Basic)</button>\n        <button (click)=\"sendPingFull()\">Ping (Full)</button>\n        Response: {{response}}`\n})\nexport class PingComponent extends AbstractBase {\n\n    public response = 'nothing yet, request something!';\n\n    constructor() {\n        super('PingComponent');\n    }\n\n    /**\n     * Send a basic ping request to the pong service.\n     */\n    public sendPingBasic(): void {\n\n        const request = this.fabric.generateFabricRequest(PongRequestType.Basic, 'basic ping');\n        this.sendPingRequest(request);\n\n    }\n\n    /**\n     * Send a full ping request to the pong service.\n     */\n    public sendPingFull(): void {\n\n        const request = this.fabric.generateFabricRequest(PongRequestType.Full, 'full ping');\n        this.sendPingRequest(request);\n\n    }\n\n    private sendPingRequest(request: PongServiceRequest): void {\n         this.bus.requestOnceWithId(GeneralUtil.genUUIDShort(), PongServiceChannel, request)\n            .handle(\n                (response: PongServiceResponse) => {\n                    this.response = response.payload;\n                }\n            );\n    }\n}"),a.Qb(),a.Ob(),a.Ob(),a.Pb(24,"p"),a.zc(25," Now that we have our "),a.Pb(26,"code",0),a.zc(27,"PingComponent"),a.Ob(),a.zc(28,", it should be able to call our "),a.Pb(29,"code",0),a.zc(30,"PongService"),a.Ob(),a.zc(31,".\n"),a.Ob(),a.Pb(32,"p"),a.zc(33,"And a version using React:"),a.Ob(),a.Pb(34,"h3"),a.zc(35,"React PingComponent"),a.Ob(),a.Pb(36,"pre",1),a.Pb(37,"code",2),a.Jb(),a.zc(38,"\nimport React, { useState } from 'react';\nimport { useTransport } from 'react-Transport';\nimport { PongRequestType, PongServiceChannel, PongServiceRequest, PongServiceResponse } from 'pong.service.model';\nimport { GeneralUtil } from '@vmw/transport/util/util';\n\nexport default function PingComponent() {\n\n    const transport = useTransport();\n    const [ pingResponse, setPingResponse ] = useState<string>('nothing yet, hit a button');\n\n    function sendPingBasic()  {\n        sendPingRequest(transport.fabric.generateFabricRequest(PongRequestType.Basic, 'basic ping'));\n     }\n\n    function sendPingFull()  {\n        sendPingRequest(transport.fabric.generateFabricRequest(PongRequestType.Full, 'full ping'));\n    }\n\n    function sendPingRequest(request: PongServiceRequest) {\n        transport.bus.requestOnceWithId(GeneralUtil.genUUIDShort(), PongServiceChannel, request)\n            .handle(\n                (response: PongServiceResponse) => {\n                    setPingResponse(response.payload);\n                }\n            );\n    }\n\n    return (\n        <div>\n            <button onClick={() => sendPingBasic()} className='btn btn-primary'>Ping (Basic)</button>\n            <button onClick={() => sendPingFull()} className='btn btn-primary'>Ping (Full)</button>\n            <br/>\n            Response: {pingResponse}\n        </div>\n    );\n}\n"),a.Qb(),a.Ob(),a.zc(39,"\n"),a.Ob(),a.Pb(40,"p"),a.zc(41," The actual code that sends the request to the service, and handles the response sent back is handled by the "),a.Pb(42,"code",0),a.zc(43,"sendPingRequest()"),a.Ob(),a.zc(44," method on the component.\n"),a.Ob(),a.Pb(45,"p"),a.zc(46," The method used in here "),a.Pb(47,"code",0),a.zc(48,"this.bus.requestOnceWithId()"),a.Ob(),a.zc(49," essentially takes in the channel you want to send your payload on, and the actual payload. This method returns what is known as a "),a.Pb(50,"code",0),a.zc(51,"MessageHandler"),a.Ob(),a.zc(52," interface. In this example we use the "),a.Pb(53,"code",0),a.zc(54,"handle()"),a.Ob(),a.zc(55," method to pass in a lambda that is executed once the response is provided by the service.\n"),a.Ob(),a.Pb(56,"p"),a.zc(57," The ID is used to ensure this the response we get back, is a response to my request only. Channels are public so in order to have 1-1 communication, you need to use the bus methods with ID's.\n"),a.Ob(),a.Pb(58,"p"),a.zc(59," The "),a.Pb(60,"code",0),a.zc(61,"handle()"),a.Ob(),a.zc(62," method also accepts an error lambda. This is executed if the service returns an error of some kind. In fact this is the exact same API signature used by "),a.Pb(63,"strong"),a.zc(64,"RxJS"),a.Ob(),a.zc(65," (which is what we used at the core of the event bus).\n"),a.Ob(),a.Pb(66,"p"),a.zc(67," One of the key benefits to using the bus, is that unlike RxJS, when an error is thrown on a stream, the stream "),a.Pb(68,"strong"),a.zc(69,"remains open"),a.Ob(),a.zc(70,". You don't have to worry about managing the subscription to that stream if something goes wrong.\n"),a.Ob(),a.Pb(71,"p"),a.zc(72," This example uses "),a.Pb(73,"code",0),a.zc(74,"requestOnce()"),a.Ob(),a.zc(75," which means a single request is sent and a single response is handled. However there are quite a few other methods available that will send a request and listen for multiple responses ("),a.Pb(76,"code",0),a.zc(77,"requestStream()"),a.Ob(),a.zc(78,") Or you could avoid sending a request altogether and just listen for responses ("),a.Pb(79,"code",0),a.zc(80,"listenStream()"),a.Ob(),a.zc(81,").\n"),a.Ob(),a.Pb(82,"p"),a.zc(83," To find out more about the available API's, You can "),a.Pb(84,"a",3),a.zc(85,"take a look at the API here"),a.Ob(),a.Ob(),a.Kb(86,"hr"),a.Pb(87,"a",4),a.zc(88,"Next Steps: Advanced Messaging"),a.Ob())},directives:[s.b],styles:[""]}),e})(),A=(()=>{class e extends k.a{constructor(e){super("AdvancedMessagingComponent"),this.highlightService=e,this.highlighted=!1}ngOnInit(){}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(t){return new(t||e)(a.Ib(z.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-advanced-messaging"]],features:[a.tb],decls:84,vars:0,consts:[[1,"clr-code"],[1,"code"],[1,"language-typescript"],[1,"p5"],["routerLink","/ts/transactions",1,"btn","btn-primary","btn-block","btn-outline"]],template:function(e,t){1&e&&(a.Pb(0,"h1"),a.zc(1,"Advanced Messaging Concepts"),a.Ob(),a.Pb(2,"p"),a.zc(3,"The basic concept of Transport is simple, but sometimes you need more control, like direct or broadcast conversations\nwithin channels. Some times you need to make sure you don't want conversations mixed up multiple components are messaging\nservices, or listening for specific responses on a s"),a.Ob(),a.Pb(4,"h3"),a.zc(5,"Understanding 'broadcast' vs 'direct' messaging"),a.Ob(),a.Pb(6,"p"),a.zc(7," Transport is analogous to Slack (for software), except Transport allows direct messages inside a channel, where as Slack opens up stand-alone conversations between actors outside of a channel. The concept however remains the same. When a component needs to restrict a conversation between its self, and a service - we can use a direct message.\n"),a.Ob(),a.Pb(8,"p"),a.zc(9," When a component is interested in everything being broadcast by a service, then that component can simply subscribe to the service channel and listen for everything.\n"),a.Ob(),a.Pb(10,"p"),a.zc(11," The use case for direct messaging between a component and service arrives when you need a specific response to be delivered to a specific component, i.e. you don't want every component getting that same response (because we're operating on a single channel). It's like talking in a public chat, vs talking in a direct message with that service.\n"),a.Ob(),a.Kb(12,"hr"),a.Pb(13,"h3"),a.zc(14,"Sending requests using ID's"),a.Ob(),a.Pb(15,"p"),a.zc(16," There are multiple ways to conduct direct messaging between a component and a service. The first is to use methods in the API that accept an ID. Every API e.g. "),a.Pb(17,"code",0),a.zc(18,"requestOnce()"),a.Ob(),a.zc(19," has multiple variations, one is the same method name that has "),a.Pb(20,"code",0),a.zc(21,"...withId()"),a.Ob(),a.zc(22," appended to the end of the name. "),a.Ob(),a.Pb(23,"p"),a.zc(24," another is "),a.Pb(25,"code",0),a.zc(26,"...withIdAndVersion()"),a.Ob(),a.zc(27,". The signature for both is mostly the same, except they obviously take an ID, or an ID and a version.\n"),a.Ob(),a.Pb(28,"p"),a.zc(29," Let's take a look at an example of using one of these methods:\n"),a.Ob(),a.Pb(30,"pre",1),a.Pb(31,"code",2),a.Jb(),a.zc(32,"const request: PongServiceRequest = {\n    command: PongRequestType.Basic,\n    message: 'basic ping'\n};\n\nthis.bus.requestOnceWithId<PongServiceRequest, PongServiceResponse>(\n    '123456',           // message id\n    PongServiceChannel, // channel on which to send request\n    request,            // payload to be sent on the channel\n    PongServiceChannel, // channel on which to listen for response **\n    'PingComponent'     // optional identifier of requesting component\n).handle(\n    (response: PongServiceResponse) => {\n        // do something with this successful request\n    },\n    (error: GeneralError) => {\n        // something went wrong, lets handle it.\n    }\n);"),a.Qb(),a.Ob(),a.Ob(),a.Pb(33,"p",3),a.Pb(34,"strong"),a.zc(35,"**"),a.Ob(),a.zc(36," In earlier versions of Transport, we used to use a different return channel for responses, this design has been phased out, however you can still use it if you need to. We're using the same request and response channel (preferred design).\n"),a.Ob(),a.Pb(37,"p"),a.zc(38," The above example will send a request to "),a.Pb(39,"code",0),a.zc(40,"PongService"),a.Ob(),a.zc(41,", but this time, we're sending that message with an ID of "),a.Pb(42,"strong"),a.zc(43,"123456"),a.Ob(),a.zc(44,". This means that the component is only going to listen for a response that "),a.Pb(45,"strong"),a.zc(46,"also contains that same ID"),a.Ob(),a.zc(47,". Any other response coming in over "),a.Pb(48,"code",0),a.zc(49,"PongServiceChannel"),a.Ob(),a.zc(50," that has a different ID, or has no ID "),a.Pb(51,"strong"),a.zc(52,"will be ignored"),a.Ob(),a.zc(53," by the "),a.Pb(54,"code",0),a.zc(55,"handle(...)"),a.Ob(),a.zc(56," method.\n"),a.Ob(),a.Kb(57,"hr"),a.Pb(58,"h3"),a.zc(59,"Quick note on generating UUID's"),a.Ob(),a.Pb(60,"p"),a.zc(61," In the example above, we used "),a.Pb(62,"strong"),a.zc(63,"123456"),a.Ob(),a.zc(64," as an ID for the message. This isn't very scalable and really you should not be worrying about generating these ID's, particularly because there could be thousands of messages being passed around channels. ID's should be generated instead of manually created.\n"),a.Ob(),a.Pb(65,"p"),a.zc(66," There is a simple utility provided by the event bus that allows you to do this easily. By using "),a.Pb(67,"code",0),a.zc(68,"GeneralUtil"),a.Ob(),a.zc(69,", you can generate full, or short UUID's. You can import "),a.Pb(70,"code",0),a.zc(71,"GeneralUtil"),a.Ob(),a.zc(72," from "),a.Pb(73,"code",0),a.zc(74,"@vmw/transport/util/util"),a.Ob(),a.zc(75,".\n"),a.Ob(),a.Pb(76,"p"),a.zc(77," It's pretty simple to use as well, all the methods are static.\n"),a.Ob(),a.Pb(78,"pre",1),a.Pb(79,"code",2),a.Jb(),a.zc(80,"GeneralUtil.genUUID();      // generates full 128bit random UUID\nGeneralUtil.genUUIDShort(); // generates full 128bit random UUID, but truncates to only the first 8 characters."),a.Qb(),a.Ob(),a.Ob(),a.Kb(81,"hr"),a.Pb(82,"a",4),a.zc(83,"Next Steps: Transactions"),a.Ob())},directives:[s.b],styles:[""]}),e})(),x=(()=>{class e extends k.a{constructor(e){super("TransactionsComponent"),this.highlightService=e,this.highlighted=!1}ngOnInit(){}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(t){return new(t||e)(a.Ib(z.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-transactions"]],features:[a.tb],decls:203,vars:0,consts:[[1,"clr-code"],[1,"code"],[1,"language-typescript"],[1,"log-output"],[1,"console-purple"],[1,"console-pink"],[1,"console-who"],[1,"console-time"],[1,"badge","badge-purple"],["routerLink","/ts/logging",1,"btn","btn-primary","btn-block","btn-outline"]],template:function(e,t){1&e&&(a.Pb(0,"h1"),a.zc(1,"Using Transactions with Transport"),a.Ob(),a.Pb(2,"p"),a.zc(3," Another technique that can be used to encapsulate a conversation between a component and a service, or between services themselves - is to use a transaction.\n"),a.Ob(),a.Pb(4,"p"),a.zc(5," Transactions via transport are not traditional transactions, in the sense that they can be rolled back if they fail, instead they are defined as a group of requests and responses that have to occur before the transaction can be considered complete.\n"),a.Ob(),a.Pb(6,"p"),a.zc(7," For example, if you need to call a number of services to get a number of responses, in order to be able to construct a response for a component - this would be a transactions. "),a.Ob(),a.Pb(8,"p"),a.zc(9," Similarly if you need to make a number of calls to services and wait for stores to be available and populated, this would also be a transaction. Transactions can be either synchronous, or asynchronous.\n"),a.Ob(),a.Pb(10,"p"),a.zc(11," Transactions are asynchronous by default. Essentially when you commit transactions, all the requests will be fired at once, the transaction will complete once responses to all those requests have been completed. These responses can arrive in any order and at any time (hence the asynchronous nature).\n"),a.Ob(),a.Pb(12,"p"),a.zc(13," However there may be times when you want your logic to run in a synchronous manner (due to your API design for example). When running a synchronous transaction, each request in the transaction will only fire once the previous one has completed. This is obviously a lot slower, but may be required based on your needs.\n"),a.Ob(),a.Pb(14,"p"),a.zc(15," Below is an example of another component that calls "),a.Pb(16,"code",0),a.zc(17,"PongService"),a.Ob(),a.zc(18," three times, via a transaction\n"),a.Ob(),a.Pb(19,"h3"),a.zc(20,"Angular PingTransactionComponent"),a.Ob(),a.Pb(21,"pre",1),a.Pb(22,"code",2),a.Jb(),a.zc(23,"import { AbstractBase } from '@vmw/transport/core';\nimport { Component } from '@angular/core';\nimport {\n    PongRequestType,\n    PongServiceChannel,\n    PongServiceRequest,\n    PongServiceResponse\n} from './pong.service.model';\nimport { BusTransaction, TransactionType, APIRequest } from '@vmw/transport';\nimport { GeneralUtil } from '@vmw/transport/util/util';\nimport { GeneralError } from '@vmw/transport/core/model/error.model';\n\n@Component({\n    selector: 'ping-transaction-component',\n    template: `\n        <button (click)=\"sendPingTransaction()\">Ping (Transaction)</button><br/>\n        <ul>\n            <li *ngFor=\"let response of responses\">{{response.value}}</li>\n        </ul>`\n})\nexport class PingTransactionComponent extends AbstractBase {\n\n    public responses: PongServiceResponse[] = [{value: 'nothing yet, request something!'}];\n\n    constructor() {\n        super('PingTransactionComponent');\n    }\n\n    /**\n     * Send a three PongService requests as a part of a transaction.\n     */\n    public sendPingTransaction(): void {\n\n        const createRequest = (type: PongRequestType, payload: string) => {\n            return this.fabric.generateFabricRequest(type, payload);\n        };\n\n        // send the same request, three times.\n        this.pingTransaction([\n            createRequest(PongRequestType.Full, 'request 1'),\n            createRequest(PongRequestType.Full, 'request 2'),\n            createRequest(PongRequestType.Full, 'request 3')\n        ]);\n    }\n\n    private pingTransaction(requests: APIRequest[]): void {\n\n        // create a transaction\n        const transaction: BusTransaction =\n            this.bus.createTransaction(TransactionType.ASYNC, GeneralUtil.genUUIDShort());\n\n        // for each request submitted, queue up a request in transaction\n        for (let request of requests) {\n\n            // add request to transaction\n            transaction.sendRequest(PongServiceChannel, request);\n        }\n\n        // register a transaction completion handler\n        transaction.onComplete<PongServiceResponse>(\n            (pongResponses: PongServiceResponse[]) => {\n\n                this.responses = [];\n\n                // push responses\n                pongResponses.forEach(\n                    (response: PongServiceResponse) => {\n                        this.responses.push(response);\n                    }\n                );\n            }\n        );\n\n        // register a transaction error handler\n        transaction.onError<GeneralError>(\n            (error: GeneralError) => {\n                // do something with this error\n            }\n        );\n\n        // run the transaction!\n        transaction.commit();\n    }\n}"),a.Qb(),a.Ob(),a.Ob(),a.Pb(24,"p"),a.zc(25,"Try it below, you can see three requests come back all made at different times, indicated by the detailed timing."),a.Ob(),a.Pb(26,"p"),a.zc(27," If you have logging enabled (debug or verbose), you should see something like the following output in your developer console."),a.Kb(28,"br"),a.Ob(),a.Pb(29,"pre",3),a.zc(30,"\u25ab\ufe0f\ufe0f "),a.Pb(31,"span",4),a.zc(32,"[Inf]:"),a.Ob(),a.zc(33," \ud83c\udfe6 "),a.Pb(34,"span",5),a.zc(35,"Transaction Created"),a.Ob(),a.zc(36," "),a.Pb(37,"span",6),a.zc(38,"[f18faebe.3a00b4ff]"),a.Ob(),a.zc(39," "),a.Pb(40,"span",7),a.zc(41,"(8:36:04 AM)"),a.Ob(),a.zc(42,"\n\ud83d\udd38 "),a.Pb(43,"span",4),a.zc(44,"[Deb]:"),a.Ob(),a.zc(45," \u23f3 "),a.Pb(46,"span",5),a.zc(47,"Transaction: Bus Request Queued: [15870062]"),a.Ob(),a.zc(48," "),a.Pb(49,"span",6),a.zc(50,"[f18faebe.3a00b4ff]"),a.Ob(),a.zc(51," "),a.Pb(52,"span",7),a.zc(53,"(8:36:04 AM)"),a.Ob(),a.zc(54,"\n\ud83d\udd38 "),a.Pb(55,"span",4),a.zc(56,"[Deb]:"),a.Ob(),a.zc(57," \u23f3 "),a.Pb(58,"span",5),a.zc(59,"Transaction: Bus Request Queued: [bcc554b4]"),a.Ob(),a.zc(60," "),a.Pb(61,"span",6),a.zc(62,"[f18faebe.3a00b4ff]"),a.Ob(),a.zc(63," "),a.Pb(64,"span",7),a.zc(65,"(8:36:04 AM)"),a.Ob(),a.zc(66,"\n\ud83d\udd38 "),a.Pb(67,"span",4),a.zc(68,"[Deb]:"),a.Ob(),a.zc(69," \u23f3 "),a.Pb(70,"span",5),a.zc(71,"Transaction: Bus Request Queued: [602430e9]"),a.Ob(),a.zc(72," "),a.Pb(73,"span",6),a.zc(74,"[f18faebe.3a00b4ff]"),a.Ob(),a.zc(75," "),a.Pb(76,"span",7),a.zc(77,"(8:36:04 AM)"),a.Ob(),a.zc(78,"\n\ud83d\udd38 "),a.Pb(79,"span",4),a.zc(80,"[Deb]:"),a.Ob(),a.zc(81," \ud83d\udc4b "),a.Pb(82,"span",5),a.zc(83,"Transaction: Completed Handler Registered"),a.Ob(),a.zc(84," "),a.Pb(85,"span",6),a.zc(86,"[f18faebe.3a00b4ff]"),a.Ob(),a.zc(87," "),a.Pb(88,"span",7),a.zc(89,"(8:36:04 AM)"),a.Ob(),a.zc(90,"\n\u25ab\ufe0f\ufe0f "),a.Pb(91,"span",4),a.zc(92,"[Inf]:"),a.Ob(),a.zc(93," \ud83c\udfe6 "),a.Pb(94,"span",5),a.zc(95,"Transaction: Starting Asynchronous"),a.Ob(),a.zc(96," "),a.Pb(97,"span",6),a.zc(98,"[f18faebe.3a00b4ff]"),a.Ob(),a.zc(99," "),a.Pb(100,"span",7),a.zc(101,"(8:36:04 AM)"),a.Ob(),a.zc(102,"\n"),a.Pb(103,"span",8),a.zc(104,"3"),a.Ob(),a.zc(105,"\ud83d\udd38 "),a.Pb(106,"span",4),a.zc(107,"[Deb]:"),a.Ob(),a.zc(108," \u27a1\ufe0f "),a.Pb(109,"span",5),a.zc(110,"Transaction: Sending Async Request to channel: services-PongService"),a.Ob(),a.zc(111," "),a.Pb(112,"span",6),a.zc(113,"[f18faebe.3a00b4ff]"),a.Ob(),a.zc(114," "),a.Pb(115,"span",7),a.zc(116,"(8:36:04 AM)"),a.Ob(),a.zc(117,"\n\ud83d\udd38 "),a.Pb(118,"span",4),a.zc(119,"[Deb]:"),a.Ob(),a.zc(120," \u2b05\ufe0f "),a.Pb(121,"span",5),a.zc(122,"Transaction: Received Async Response on channel: services-PongService"),a.Ob(),a.zc(123," "),a.Pb(124,"span",6),a.zc(125,"[f18faebe.3a00b4ff]"),a.Ob(),a.zc(126," "),a.Pb(127,"span",7),a.zc(128,"(8:36:04 AM)"),a.Ob(),a.zc(129,"\n\ud83d\udd38 "),a.Pb(130,"span",4),a.zc(131,"[Deb]:"),a.Ob(),a.zc(132," "),a.Pb(133,"span",5),a.zc(134,"* Dropping Message 16b12963, handler only online for ae71734e"),a.Ob(),a.zc(135," "),a.Pb(136,"span",6),a.zc(137,"[f18faebe]"),a.Ob(),a.zc(138," "),a.Pb(139,"span",7),a.zc(140,"(8:36:04 AM)"),a.Ob(),a.zc(141,"\n\ud83d\udd38 "),a.Pb(142,"span",4),a.zc(143,"[Deb]:"),a.Ob(),a.zc(144," "),a.Pb(145,"span",5),a.zc(146,"* Dropping Message 16b12963, handler only online for ae90e95e"),a.Ob(),a.zc(147," "),a.Pb(148,"span",6),a.zc(149,"[f18faebe]"),a.Ob(),a.zc(150," "),a.Pb(151,"span",7),a.zc(152,"(8:36:04 AM)"),a.Ob(),a.zc(153,"\n\ud83d\udd38 "),a.Pb(154,"span",4),a.zc(155,"[Deb]:"),a.Ob(),a.zc(156," \u2b05\ufe0f "),a.Pb(157,"span",5),a.zc(158,"Transaction: Received Async Response on channel: services-PongService"),a.Ob(),a.zc(159," "),a.Pb(160,"span",6),a.zc(161,"[f18faebe.3a00b4ff]"),a.Ob(),a.zc(162," "),a.Pb(163,"span",7),a.zc(164,"(8:36:04 AM)"),a.Ob(),a.zc(165,"\n\ud83d\udd38 "),a.Pb(166,"span",4),a.zc(167,"[Deb]:"),a.Ob(),a.zc(168," "),a.Pb(169,"span",5),a.zc(170,"* Dropping Message ae71734e, handler only online for ae90e95e"),a.Ob(),a.zc(171," "),a.Pb(172,"span",6),a.zc(173,"[f18faebe]"),a.Ob(),a.zc(174," "),a.Pb(175,"span",7),a.zc(176,"(8:36:04 AM)"),a.Ob(),a.zc(177,"\n\ud83d\udd38 "),a.Pb(178,"span",4),a.zc(179,"[Deb]:"),a.Ob(),a.zc(180," \u2b05\ufe0f "),a.Pb(181,"span",5),a.zc(182,"Transaction: Received Async Response on channel: services-PongService"),a.Ob(),a.zc(183," "),a.Pb(184,"span",6),a.zc(185,"[f18faebe.3a00b4ff]"),a.Ob(),a.zc(186," "),a.Pb(187,"span",7),a.zc(188,"(8:36:04 AM)"),a.Ob(),a.zc(189,"\n\u25ab\ufe0f\ufe0f "),a.Pb(190,"span",4),a.zc(191,"[Inf]:"),a.Ob(),a.zc(192," \ud83c\udf89 "),a.Pb(193,"span",5),a.zc(194,"Transaction Completed"),a.Ob(),a.zc(195," "),a.Pb(196,"span",6),a.zc(197,"[f18faebe.3a00b4ff] (8:36:04 AM)"),a.Ob(),a.Ob(),a.Pb(198,"p"),a.zc(199," All of the underlying handling of requests, responses and mappings are encapsulated by the transaction. Each request has it's own ID and is individually tracked by the transaction, this allows any number of transactions to be operating simultaneously at any one time on a channel.\n"),a.Ob(),a.Kb(200,"hr"),a.Pb(201,"a",9),a.zc(202,"Next Steps: Logging"),a.Ob())},directives:[s.b],styles:[""]}),e})(),I=(()=>{class e extends k.a{constructor(e){super("TransactionsComponent"),this.highlightService=e,this.highlighted=!1}ngOnInit(){}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(t){return new(t||e)(a.Ib(z.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-logging"]],features:[a.tb],decls:78,vars:0,consts:[[1,"clr-code"],["href","https://github.com/vmware/transport-typescript/blob/master/src/log/logger.service.ts"],[1,"code"],[1,"language-typescript"],[1,"log-output"],[1,"console-purple"],[1,"console-pink"],[1,"console-orange"],[1,"console-red"],["routerLink","/ts/broker-overview",1,"btn","btn-primary","btn-block","btn-outline"]],template:function(e,t){1&e&&(a.Pb(0,"h1"),a.zc(1,"Logging"),a.Ob(),a.Pb(2,"h3"),a.zc(3," >> Please don't use "),a.Pb(4,"code",0),a.zc(5,"console.log()"),a.Ob(),a.zc(6," <<\n"),a.Ob(),a.Pb(7,"p"),a.zc(8," When using any of the abstractions provided, they all extend from a single base class called "),a.Pb(9,"code",0),a.zc(10,"AbstractCore"),a.Ob(),a.zc(11,". A key property provided is "),a.Pb(12,"code",0),a.zc(13,"this.log"),a.Ob(),a.zc(14,", which is a reference to a global singleton logger of type "),a.Pb(15,"code",0),a.zc(16,"Logger"),a.Ob(),a.zc(17,". You can read the API here: "),a.Pb(18,"a",1),a.zc(19," https://github.com/vmware/transport-typescript/blob/master/src/log/logger.service.ts"),a.Ob(),a.zc(20,". "),a.Ob(),a.Pb(21,"p"),a.zc(22," This follows standard logging design that allows you to configure the logging level, styling and also log messages to the console with varying levels. Currently the logger supports "),a.Pb(23,"code",0),a.zc(24,"VERBOSE, DEBUG, INFO, WARN, ERROR"),a.Ob(),a.zc(25," levels.\n"),a.Ob(),a.Pb(26,"p"),a.zc(27," To log to the console, all you need (from any class implementing an abstraction) is call "),a.Pb(28,"code",0),a.zc(29,"this.log"),a.Ob(),a.zc(30,", and then the level you want to log at. For example ("),a.Pb(31,"code",0),a.zc(32,"verbose(obj), debug(obj), info(obj), warn(obj), error(ob)"),a.Ob(),a.zc(33,". Below is an example of all the log level methods being called.\n"),a.Ob(),a.Pb(34,"h4"),a.zc(35,"Logging Level Example"),a.Ob(),a.Pb(36,"pre",2),a.Pb(37,"code",3),a.Jb(),a.zc(38,"import { AbstractBase } from '@vmw/transport/core';\nimport { LogLevel } from '@vmw/transport/log';\nimport { Component } from '@angular/core';\n\n@Component({\n    selector: 'log-component',\n    template: `\n        <button (click)=\"logMessages()\">Log To Console</button>`\n})\nexport class LogComponent extends AbstractBase {\n\n    constructor() {\n        super('LogComponent');\n\n        // turn on verbose logging for our bus.\n        this.bus.api.setLogLevel(LogLevel.Verbose);\n    }\n\n    /**\n     * Log messages to the console.\n     */\n    public logMessages(): void {\n        this.log.verbose('this is a Verbose log message');\n        this.log.debug('this is a Debug log message');\n        this.log.info('this is an Info log message');\n        this.log.warn('this is a Warn log message');\n        this.log.error('this is an Error log message');\n    }\n}"),a.Qb(),a.Ob(),a.Ob(),a.Pb(39,"p"),a.zc(40," Which should output the following in your developer tools console. (FYI, WARN and ERROR messages will provide a stack trace also).\n"),a.Ob(),a.Pb(41,"pre",4),a.zc(42,"\ud83d\udccd\ufe0f\ufe0f\ufe0f "),a.Pb(43,"span",5),a.zc(44,"[Ver]:"),a.Ob(),a.zc(45," "),a.Pb(46,"span",6),a.zc(47,"This is a Verbose log message"),a.Ob(),a.zc(48,"\n\ud83d\udd38\ufe0f "),a.Pb(49,"span",5),a.zc(50,"[Deb]:"),a.Ob(),a.zc(51," "),a.Pb(52,"span",6),a.zc(53,"This is a Debug log message"),a.Ob(),a.zc(54,"\n\u25ab\ufe0f "),a.Pb(55,"span",5),a.zc(56,"[Inf]:"),a.Ob(),a.zc(57," "),a.Pb(58,"span",6),a.zc(59,"This is an Info log message"),a.Ob(),a.zc(60,"\n\u26a0\ufe0f "),a.Pb(61,"span",7),a.zc(62,"[Warn]:"),a.Ob(),a.zc(63,"  "),a.Pb(64,"span",7),a.zc(65,"This is a Warn log message"),a.Ob(),a.zc(66,"\n\ud83d\udd34 "),a.Pb(67,"span",8),a.zc(68,"[Error]:"),a.Ob(),a.zc(69," "),a.Pb(70,"span",8),a.zc(71,"This is an Error log message"),a.Ob(),a.zc(72,"\n"),a.Ob(),a.Pb(73,"p"),a.zc(74," Open the developer console to see logging output.\n"),a.Ob(),a.Kb(75,"hr"),a.Pb(76,"a",9),a.zc(77,"Next Steps: Extending To A Broker Overview"),a.Ob())},directives:[s.b],styles:[""]}),e})(),q=(()=>{class e extends k.a{constructor(e){super("BrokerOverviewComponent"),this.highlightService=e,this.highlighted=!1}ngOnInit(){}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(t){return new(t||e)(a.Ib(z.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-broker-overview"]],features:[a.tb],decls:79,vars:0,consts:[["href","http://stomp.github.io/","target","_blank"],[1,"emphasis"],[1,"list"],["href","http://stomp.github.io/implementations.html","target","_blank"],["href","https://www.oreilly.com/library/view/understanding-message-brokers/9781492049296/","target","_blank"],[1,"clr-code"],[1,"code"],[1,"language-typescript"],["routerLink","/ts/connecting-broker",1,"btn","btn-primary","btn-block","btn-outline"]],template:function(e,t){1&e&&(a.Pb(0,"h1"),a.zc(1,"Extending Transport to a Message Broker."),a.Ob(),a.Pb(2,"p"),a.zc(3," Transport provides a decoupling mechanism between consumers and producers, via a universal API that makes pub-sub simple across any set of distributed applications. This also allows us to locate producers and consumers where-ever we want across applications.\n"),a.Ob(),a.Pb(4,"p"),a.zc(5," When you extend to a broker, you will be extending your local event bus, to a distributed event bus via a message/event broker. This distributed event bus can have sources, relays, producers, consumers and integrations. We call this concept a '"),a.Pb(6,"strong"),a.zc(7,"fabric"),a.Ob(),a.zc(8,"'.\n"),a.Ob(),a.Pb(9,"p"),a.zc(10," As a developer, you would simply mark which channels you'd like to make 'Galactic' and they would be automatically bridged from your local application bus to the broker. A 'Galactic' Channel is a channel on the bus that has been extended to a broker destination (like a topic or a queue).\n"),a.Ob(),a.Pb(11,"p"),a.zc(12," The bus is designed to be extended, to child applications running in iframes, web components, shadow DOM - and to backend systems. This is key to making the distributed pattern work. The concept being that services can run in any platform, running any technology - but can communicate with one another. The literal transport mechanism between apps becomes irrelevant, every actor in the system becomes either a producer or a consumer, as peers.\n"),a.Ob(),a.Kb(13,"hr"),a.Pb(14,"h3"),a.zc(15,"How the browser connects to the 'fabric'."),a.Ob(),a.Pb(16,"p"),a.zc(17," The browser connects to brokers via a WebSocket. The wire protocol used on the WebSocket is "),a.Pb(18,"a",0),a.zc(19,"STOMP"),a.Ob(),a.zc(20,". STOMP stands for "),a.Pb(21,"span",1),a.zc(22,"Simple Text Oriented Messaging Protocol."),a.Ob(),a.Ob(),a.Kb(23,"hr"),a.Pb(24,"h4"),a.zc(25,"Why STOMP?"),a.Ob(),a.Pb(26,"ol",2),a.Pb(27,"li"),a.zc(28," It's a standard Pub-Sub protocol that is "),a.Pb(29,"a",3),a.zc(30,"widely accepted"),a.Ob(),a.zc(31,". It means the fabric is compatible with any STOMP broker. "),a.Ob(),a.Pb(32,"li"),a.zc(33," You cannot talk AMQP over a WebSocket, Which means without STOMP, we can't talk directly to ANY broker. "),a.Ob(),a.Ob(),a.Kb(34,"hr"),a.Pb(35,"h3"),a.zc(36," What happens when I connect to a broker\n"),a.Ob(),a.Pb(37,"p"),a.zc(38," Any channel that your application has been designated as 'galactic' will be automatically extended to the broker. It does this by mapping the channel name on your local bus, to a topic on the broker. If you open your developer tools, look\n"),a.Ob(),a.Pb(39,"p"),a.zc(40," If you don't know what a topic is, or you would like to know more about this stuff, "),a.Pb(41,"a",4),a.zc(42,"here is a great introduction."),a.Ob(),a.Ob(),a.Kb(43,"hr"),a.Pb(44,"h3"),a.zc(45,"Galactic Channels"),a.Ob(),a.Pb(46,"p"),a.zc(47," Galactic Channels are the same as regular channels, except they are distributed to the fabric. The idea here is that we don't want every channel on the bus distributed. When you create a galactic channel, you are bridging that specific channel from the browser, to the fabric. In pub-sub. this is the concept of subscribing to a destination topic or queue.\n"),a.Ob(),a.Pb(48,"p"),a.zc(49," You can create Galactic Channels at any time, once the Broker Connector is connected to a broker, those Galactic channels will be distributed.\n"),a.Ob(),a.Kb(50,"hr"),a.Pb(51,"h4"),a.zc(52,"How do I create a galactic channel?"),a.Ob(),a.Pb(53,"p"),a.zc(54," If you want to extend a local channel to the fabric, you can use the "),a.Pb(55,"code",5),a.zc(56,"markChannelAsGalactic()"),a.Ob(),a.zc(57," method.\n"),a.Ob(),a.Pb(58,"pre",6),a.Pb(59,"code",7),a.Jb(),a.zc(60,"this.bus.markChannelAsGalactic('simple-stream');"),a.Qb(),a.Ob(),a.Ob(),a.Pb(61,"p"),a.zc(62," This will result in a subscription to a topic with the same name as your channel. You won't have to worry about any of that however.\n"),a.Ob(),a.Kb(63,"hr"),a.Pb(64,"h4"),a.zc(65,"How do I stop extending a channel to the broker?"),a.Ob(),a.Pb(66,"p"),a.zc(67," If you want to stop extending a channel to the broker (no longer galactic) then you can use the "),a.Pb(68,"code",5),a.zc(69,"markChannelAsLocal()"),a.Ob(),a.zc(70," method.\n"),a.Ob(),a.Pb(71,"pre",6),a.Pb(72,"code",7),a.Jb(),a.zc(73,"this.bus.markChannelAsLocal('simple-stream');"),a.Qb(),a.Ob(),a.Ob(),a.Pb(74,"p"),a.zc(75," This will result in an unsubscription from the topic with the same name as your channel. You won't have to worry about any of that however.\n"),a.Ob(),a.Kb(76,"hr"),a.Pb(77,"a",8),a.zc(78,"Next Steps: Connecting to a Broker"),a.Ob())},directives:[s.b],styles:[""]}),e})(),R=(()=>{class e extends k.a{constructor(e){super("ConnectingBrokerComponent"),this.highlightService=e,this.highlighted=!1}ngOnInit(){}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(t){return new(t||e)(a.Ib(z.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-connecting-broker"]],features:[a.tb],decls:84,vars:0,consts:[["href","http://stomp.github.io/","target","_blank"],[1,"code"],[1,"language-typescript"],["href","https://stackblitz.com/edit/angular-kk6cyh"],["src",a.Ec("https://stackblitz.com/edit/angular-kk6cyh?ctl=1&devtoolsheight=33&embed=1&file=src/app/app.component.ts&theme=dark"),1,"stackblitz"],["role","alert",1,"alert","alert-info"],[1,"alert-items"],[1,"alert-item","static"],[1,"alert-icon-wrapper"],["shape","exclamation-circle",1,"alert-icon"],[1,"alert-text"],[1,"clr-code"],[1,"list"],[1,"emphasis"],["routerLink","/ts/multiple-brokers",1,"btn","btn-primary","btn-block","btn-outline"]],template:function(e,t){1&e&&(a.Pb(0,"h3"),a.zc(1,"Connecting to a broker"),a.Ob(),a.Pb(2,"p"),a.zc(3," If you're using the Java or Golang version of Transport, they both come with a local, very simple broker that you can run. However because Transport uses "),a.Pb(4,"a",0),a.zc(5,"STOMP"),a.Ob(),a.zc(6,", it means you can connect directly to any STOMP compatible broker (like RabbitMQ for example).\n"),a.Ob(),a.Pb(7,"h4"),a.zc(8,"How do I connect my bus to a broker?"),a.Ob(),a.Pb(9,"p"),a.zc(10," We've tried to keep this as simple as possible. You should really just need to provide a connected and disconnected event handler.\n"),a.Ob(),a.Pb(11,"pre",1),a.Pb(12,"code",2),a.Jb(),a.zc(13,"// Set up the bus, before we load any of the app.\nconst bus: EventBus = BusUtil.bootBus();\n\n// Called when connected to broker\nconst connectedHandler = (sessionId: string) => {\n    bus.logger.info(`Connected to Broker with sessionId ${sessionId}`, 'main.ts');\n};\n\n// Called when disconnected.\nconst disconnectedHandler = () => {\n    bus.logger.info('Disconnected from Broker.', 'main.ts');\n}\n\n// Connect to Broker, this a real working end-point.\nbus.fabric.connect(connectedHandler, disconnectedHandler, 'transport-bus.io', 443, '/ws', true);\n"),a.Qb(),a.Ob(),a.Ob(),a.Pb(14,"p"),a.zc(15," If you need to configure the endpoint, host, port etc, you can also pass those in also as optional args.\n"),a.Ob(),a.Kb(16,"hr"),a.Pb(17,"p"),a.zc(18," Disconnecting is easy, you'll go offline instantly.\n"),a.Ob(),a.Pb(19,"h4"),a.zc(20,"Disconnecting from broker"),a.Ob(),a.Pb(21,"pre",1),a.Pb(22,"code",2),a.Jb(),a.zc(23,"// Disconnect (close socket completely).\nbus.fabric.disconnect();"),a.Qb(),a.Ob(),a.Ob(),a.Pb(24,"h4"),a.Pb(25,"a",3),a.zc(26,"Try it out in StackBlitz"),a.Ob(),a.Ob(),a.Kb(27,"iframe",4),a.Pb(28,"div",5),a.Pb(29,"div",6),a.Pb(30,"div",7),a.Pb(31,"div",8),a.Kb(32,"clr-icon",9),a.Ob(),a.Pb(33,"span",10),a.zc(34," You can always use the built in abstractions that can give you access to the "),a.Pb(35,"code",11),a.zc(36,"bus"),a.Ob(),a.zc(37," and "),a.Pb(38,"code",11),a.zc(39,"fabric"),a.Ob(),a.zc(40," and "),a.Pb(41,"code",11),a.zc(42,"storeManager"),a.Ob(),a.zc(43," instances, without having to do anything. "),a.Ob(),a.Ob(),a.Ob(),a.Ob(),a.Kb(44,"hr"),a.Pb(45,"h3"),a.zc(46,"How does my application monitor the broker connection state?"),a.Ob(),a.Pb(47,"p"),a.zc(48," How do I know if my application gets knocked offline? What if there is a hiccup on the WebSocket? The "),a.Pb(49,"code",11),a.zc(50,"this.fabric.whenConnectionStateChanges()"),a.Ob(),a.zc(51," returns a "),a.Pb(52,"code",11),a.zc(53,"StoreStream<FabricConnectionState>"),a.Ob(),a.zc(54," instance, that will stream connection state changes to the consumer.\n"),a.Ob(),a.Pb(55,"p"),a.zc(56," There are three different state changes emitted from this stream.\n"),a.Ob(),a.Pb(57,"ol",12),a.Pb(58,"li"),a.Pb(59,"code",11),a.zc(60,"FabricConnectionState.Connected"),a.Ob(),a.zc(61," - "),a.Pb(62,"span",13),a.zc(63,"Broker connected!"),a.Ob(),a.Ob(),a.Pb(64,"li"),a.Pb(65,"code",11),a.zc(66,"FabricConnectionState.Disconnected"),a.Ob(),a.zc(67," - "),a.Pb(68,"span",13),a.zc(69,"Broker disconnected!"),a.Ob(),a.Ob(),a.Pb(70,"li"),a.Pb(71,"code",11),a.zc(72,"FabricConnectionState.Failed"),a.Ob(),a.zc(73," - "),a.Pb(74,"span",13),a.zc(75,"Broker unable to connect!"),a.Ob(),a.Ob(),a.Ob(),a.Pb(76,"h4"),a.zc(77,"Using whenConnectionStateChanges()"),a.Ob(),a.Pb(78,"pre",1),a.Pb(79,"code",2),a.Jb(),a.zc(80,"import { FabricApi, FabricConnectionState } from '@vmw/transport/fabric.api';\n\nthis.fabric.whenConnectionStateChanges()\n    .subscribe(\n        (stateChange: FabricConnectionState) => {\n            switch (stateChange) {\n                case FabricConnectionState.Connected:\n                    // .. do something, now we're online.\n                    break;\n\n                case FabricConnectionState.Disconnected:\n                    // .. do something, now we're offline.\n                    break;\n\n                case FabricConnectionState.Failed:\n                    // .. do something important, we can't connect!\n                    break;\n                }\n            }\n     );\n"),a.Qb(),a.Ob(),a.Ob(),a.Kb(81,"hr"),a.Pb(82,"a",14),a.zc(83,"Next Steps: Connecting to multiple brokers"),a.Ob())},directives:[r.d,r.b,s.b],styles:[""]}),e})(),M=(()=>{class e extends k.a{constructor(e){super("MultipleBrokersComponent"),this.highlightService=e,this.highlighted=!1}ngOnInit(){}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(t){return new(t||e)(a.Ib(z.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-multiple-brokers"]],features:[a.tb],decls:65,vars:0,consts:[[1,"clr-code"],[1,"code"],[1,"language-typescript"],["routerLink","./ts/connecting-broker"],["routerLink","/ts/extending-channels",1,"btn","btn-primary","btn-block","btn-outline"]],template:function(e,t){1&e&&(a.Pb(0,"h1"),a.zc(1," Connecting to multiple brokers\n"),a.Ob(),a.Pb(2,"h3"),a.zc(3,"One UI, multiple brokers"),a.Ob(),a.Pb(4,"p"),a.zc(5," Sometimes you want to connect to more than one fabric endpoint in your UI. You can easily achieve that by using the same method as when you would connect to a single fabric instance. "),a.Ob(),a.Pb(6,"p"),a.zc(7," As long as brokers follow the STOMP v1.2 specifications and are provided through either Transport or any other means, you can communicate with galactic channels across multiple brokers. See below the detailed step-by-step guide to learn how to leverage this feature and what to look out for.\n"),a.Ob(),a.Kb(8,"hr"),a.Pb(9,"h3"),a.zc(10,"Step 1: Connect to multiple brokers"),a.Ob(),a.Pb(11,"p"),a.zc(12," Connecting to multiple Transport instances is no different from connecting to a single instance. You create connection and disconnection handlers per broker and establish connection using "),a.Pb(13,"code",0),a.zc(14,"fabric.connect()"),a.Ob(),a.zc(15,".\n"),a.Ob(),a.Pb(16,"pre",1),a.Pb(17,"code",2),a.Jb(),a.zc(18,"// first endpoint\nthis.fabric.connect(\n    () => {},\n    () => {},\n    'mybroker.mycompany.com'\n);\n\n// second endpoint\nthis.fabric.connect(\n    () => {},\n    () => {},\n    'somehost',\n    12345,\n    '/custom-fabric-endpoint'\n);\n"),a.Qb(),a.Ob(),a.Ob(),a.Pb(19,"p"),a.zc(20," Next, you may want to set up listeners for connection events for the brokers using "),a.Pb(21,"code",0),a.zc(22,"fabric.whenConnectionStateChanges()"),a.Ob(),a.zc(23,".\n"),a.Ob(),a.Pb(24,"pre",1),a.Pb(25,"code",2),a.Jb(),a.zc(26,"this.bus.fabric.whenConnectionStateChanges(\n    BusUtil.getFabricConnectionString('mybroker.mycompany.com', 80, '/fabric'))\n        .subscribe((state: FabricConnectionState) => { ... } );\n"),a.Qb(),a.Ob(),a.Ob(),a.Kb(27,"hr"),a.Pb(28,"h3"),a.zc(29,"Step 2: Mark galactic channels across multiple fabric endpoints"),a.Ob(),a.Pb(30,"p"),a.zc(31," Just like you would in the previous chapter, "),a.Pb(32,"a",3),a.zc(33," Connecting to the Fabric"),a.Ob(),a.zc(34,", you use the same "),a.Pb(35,"code",0),a.zc(36,"bus.markChannelAsGalactic()"),a.Ob(),a.zc(37," for marking a channel galactic and "),a.Pb(38,"code",0),a.zc(39,"bus.markChannelAsLocal()"),a.Ob(),a.zc(40," for converting it back to a local channel. A major difference to keep in mind though is that when you have more than one broker session connected, you will need to specify the target broker endpoint, as a second parameter, that you wish to associate the channel with:\n"),a.Ob(),a.Pb(41,"pre",1),a.Pb(42,"code",2),a.Jb(),a.zc(43,"// mark channel-A as galactic on the first broker\nthis.bus.markChannelAsGalactic('channel-A',\n    BusUtil.getFabricConnectionString('mybroker.mycompany.com', 80, '/fabric'));\n\n// mark channel-B as galactic on the second broker\nthis.bus.markChannelAsGalactic('channel-B',\n    BusUtil.getFabricConnectionString('somehost', 12345, '/custom-fabric-endpoint'));\n"),a.Qb(),a.Ob(),a.Ob(),a.Pb(44,"p"),a.zc(45," If you don't specify the second parameter, Transport will not be able to tell which channel should be mapped to which broker and eventually throws an error in the console asking you to explicitly provide it. "),a.Pb(46,"strong"),a.zc(47,"If there is only one broker to connect to, however, you don't need to provide the second parameter"),a.Ob(),a.zc(48,", as Transport will automatically fill it out for you.\n"),a.Ob(),a.Pb(49,"p"),a.zc(50," And that is how to talk to galactic channels mapped across different brokers!\n"),a.Ob(),a.Kb(51,"hr"),a.Pb(52,"h3"),a.zc(53,"Extra: Multiple galactic channels across distributed brokers with the same channel name"),a.Ob(),a.Pb(54,"p"),a.zc(55," In the example above, we mapped two channels of differing names to their respective broker. It naturally makes sense that you will invoke different channels for different operations. However, you can assign the same channel name to the both mappings if you meet the following conditions:\n"),a.Ob(),a.Kb(56,"br"),a.Pb(57,"ol"),a.Pb(58,"li"),a.zc(59," All of your distributed brokers communicate over WebSocket with STOMP "),a.Ob(),a.Pb(60,"li"),a.zc(61," The channel deals with the same type of request and response data no matter what broker instance "),a.Ob(),a.Ob(),a.Kb(62,"hr"),a.Pb(63,"a",4),a.zc(64,"Next Steps: extending channels"),a.Ob())},directives:[s.b],styles:[""]}),e})(),L=(()=>{class e extends k.a{constructor(e){super("ExtendingChannelsComponent"),this.highlightService=e,this.highlighted=!1}ngOnInit(){}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(t){return new(t||e)(a.Ib(z.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-extending-channels"]],features:[a.tb],decls:72,vars:0,consts:[[1,"emphasis"],["href","https://github.com/vmware/transport-typescript/blob/master/src/bus.api.ts#L446"],[1,"clr-code"],[1,"code"],[1,"language-typescript"],["routerLink","/java/overview"],["routerLink","/golang/overview"],["href","https://github.com/vmware/transport-typescript/blob/master/src/fabric.api.ts#L92"],["routerLink","/ts/store-basics",1,"btn","btn-primary","btn-block","btn-outline"]],template:function(e,t){1&e&&(a.Pb(0,"h1"),a.zc(1,"Extending local channels to be 'Galactic' Channels."),a.Ob(),a.Pb(2,"p"),a.zc(3," Extending channels is the concept of being able to decide which channels you extend to a broker, and how you map them to destinations on those brokers.\n"),a.Ob(),a.Pb(4,"h2"),a.zc(5,"Galactic Channels"),a.Ob(),a.Pb(6,"p"),a.zc(7," When Transport was being developed, it was originally had a code name of 'Bifr\xf6st'. The term 'Galactic' Channel, stems from the idea that you could extend a channel to any other destination, on any compatible broker.\n"),a.Ob(),a.Pb(8,"p"),a.zc(9," Essentially, marking a channel as galactic "),a.Pb(10,"strong",0),a.zc(11,"extends it to a broker destination"),a.Ob(),a.zc(12,", marking it as local "),a.Pb(13,"strong",0),a.zc(14,"boxes it to the local application"),a.Ob(),a.zc(15," only.\n"),a.Ob(),a.Kb(16,"hr"),a.Pb(17,"h2"),a.zc(18,"Marking a channel as Galactic"),a.Ob(),a.Pb(19,"p"),a.zc(20," Use the "),a.Pb(21,"a",1),a.Pb(22,"code",2),a.zc(23,"bus.markChannelAsGalactic()"),a.Ob(),a.Ob(),a.zc(24," method. You can supply a broker identity, if you're using multiple brokers, to make sure you don't extend channels to all brokers.\n"),a.Ob(),a.Pb(25,"pre",3),a.Pb(26,"code",4),a.Jb(),a.zc(27,"this.bus.markChannelAsGalactic('simple-stream');"),a.Qb(),a.Ob(),a.Ob(),a.Pb(28,"p"),a.zc(29," To stop extending a channel, use the "),a.Pb(30,"code",2),a.zc(31,"bus.markChannelAsLocal()"),a.Ob(),a.zc(32," method"),a.Ob(),a.Pb(33,"pre",3),a.Pb(34,"code",4),a.Jb(),a.zc(35,"this.bus.markChannelAsLocal('simple-stream');"),a.Qb(),a.Ob(),a.Ob(),a.Kb(36,"hr"),a.Pb(37,"h2"),a.zc(38,"Private Channels (Topics)"),a.Ob(),a.Pb(39,"p"),a.zc(40," If you're using the "),a.Pb(41,"a",5),a.zc(42,"Java"),a.Ob(),a.zc(43," or "),a.Pb(44,"a",6),a.zc(45,"Golang"),a.Ob(),a.zc(46," version of Transport as your backend/service broker, you can use the optional "),a.Pb(47,"code",2),a.zc(48,"isPrivate"),a.Ob(),a.zc(49," argument and set it to true. This will use a queue instead of a topic to communicate with your backend service. This is important if you don't want other clients or components in your applications to pick up this traffic.\n"),a.Ob(),a.Pb(50,"h4"),a.zc(51," Using "),a.Pb(52,"a",7),a.Pb(53,"code",2),a.zc(54,"this.fabric.generateFabricRequest"),a.Ob(),a.Ob(),a.zc(55,"?\n"),a.Ob(),a.Pb(56,"p"),a.zc(57," This method creates a fabric ready request, capable of being routed across to services that are listening on remote / galactic channels, and that are using the Transport Java or Golang. You supply a command and an optional payload to send.\n"),a.Ob(),a.Pb(58,"h4"),a.zc(59," Can I message over galactic channels without using "),a.Pb(60,"a",7),a.Pb(61,"code",2),a.zc(62,"this.fabric.generateFabricRequest"),a.Ob(),a.Ob(),a.zc(63,"?\n"),a.Ob(),a.Pb(64,"p"),a.zc(65," Yes. You can send what ever you like.\n"),a.Ob(),a.Kb(66,"hr"),a.Pb(67,"h4"),a.zc(68," \ud83d\udc49 Use requests that operate over ID's or Transactions instead of public requests/responses to avoid crosstalk. \ud83d\udc48\n"),a.Ob(),a.Kb(69,"hr"),a.Pb(70,"a",8),a.zc(71,"Next Steps: store basics"),a.Ob())},directives:[s.b],styles:[""]}),e})(),B=(()=>{class e extends k.a{constructor(e){super("TransactionsComponent"),this.highlightService=e,this.highlighted=!1}ngOnInit(){}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(t){return new(t||e)(a.Ib(z.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-store-basics"]],features:[a.tb],decls:103,vars:0,consts:[["href","http://www.ehcache.org/","target","_blank"],[1,"clr-code"],["href","https://github.com/vmware/transport-typescript/blob/master/src/store.api.ts"],[1,"code"],[1,"language-typescript"],["routerLink","/ts/store-advanced",1,"btn","btn-primary","btn-block","btn-outline"]],template:function(e,t){1&e&&(a.Pb(0,"h1"),a.zc(1,"Understanding and using Stores."),a.Ob(),a.Pb(2,"h3"),a.zc(3,"Stores are used to represent source-of-truth state in your applications."),a.Ob(),a.Kb(4,"p"),a.Pb(5,"p"),a.zc(6," Transport provides a very simple API for creating a single source of truth for state inside your app.\n"),a.Ob(),a.Pb(7,"p"),a.zc(8," The store API has no dependencies on other frameworks. The design was lifted from "),a.Pb(9,"a",0),a.zc(10,"EHCache"),a.Ob(),a.zc(11,", a well known, supported and widely used industry standard cache platform for Java.\n"),a.Ob(),a.Pb(12,"p"),a.zc(13," You can create as many different stores as you like, each store should ideally contain a single type of object mixing objects types in a store is generally a bad design. For each type of object you want to maintain state for, you would create a store for that object. Once you have created a store, you can populate it with an existing single object collection of objects.\n"),a.Ob(),a.Pb(14,"p"),a.zc(15," The store you create is essentially a hash map of key's to values. When you put an object into your store, you give it a unique key (which is a string you define). Once an object is in the store, every and any actor inside your application can pull that specific object (or all objects) from that store as there is only a single instance of the store inside your application. There is no defined limit to the number of stores you can create and the number of objects you can keep in that store.\n"),a.Ob(),a.Kb(16,"hr"),a.Pb(17,"h2"),a.zc(18,"Creating Stores"),a.Ob(),a.Pb(19,"p"),a.zc(20," Every class that extends from "),a.Pb(21,"code",1),a.zc(22,"AbstractBase"),a.Ob(),a.zc(23," or "),a.Pb(24,"code",1),a.zc(25,"AbstractCore"),a.Ob(),a.zc(26," will receive a reference to "),a.Pb(27,"code",1),a.zc(28,"this.storeManager"),a.Ob(),a.zc(29,". This object has has a type of "),a.Pb(30,"code",1),a.Pb(31,"a",2),a.zc(32,"BusStoreApi"),a.Ob(),a.Ob(),a.zc(33,".\n"),a.Ob(),a.Pb(34,"p"),a.zc(35," In order to create a store, you can use the method "),a.Pb(36,"code",1),a.zc(37,"this.storeManager.createStore(objectType: StoreType, map?: Map<UUID, T>)"),a.Ob(),a.zc(38,". The only mandatory argument is the 'type' of the store ("),a.Pb(39,"code",1),a.zc(40,"StoreType"),a.Ob(),a.zc(41,") which is actually just a string. The second argument allows you to pass a pre-populated map to the store that will populate it with all the key / values of the supplied map.\n"),a.Ob(),a.Pb(42,"h3"),a.zc(43,"Creating 'MyObject' Store"),a.Ob(),a.Pb(44,"pre",3),a.Pb(45,"code",4),a.Jb(),a.zc(46,"interface MyObject {\n    message: string\n}\n\n// create a store called 'MyObject' that holds instances of MyObject\nconst myStore: BusStore<MyObject> = this.storeManager.createStore<MyObject>('MyObject');"),a.Qb(),a.Ob(),a.Ob(),a.Pb(47,"p"),a.zc(48," You have just created an empty store that is named 'MyObject' that is now supposed to hold objects of type "),a.Pb(49,"code",1),a.zc(50,"MyObject"),a.Ob(),a.zc(51,". "),a.Pb(52,"strong"),a.zc(53,"You can only create a store once"),a.Ob(),a.zc(54,", it exists as a singleton. If you make another call to create a store with the same name/object type definition - you will receive a reference to the same (already created and existing store).\n"),a.Ob(),a.Pb(55,"p"),a.Pb(56,"code",1),a.zc(57,"this.storeManager.createStore()"),a.Ob(),a.zc(58," is safe to use always to gain a reference to your store, it won't re-create it, if it already exists.\n"),a.Ob(),a.Kb(59,"hr"),a.Pb(60,"h2"),a.zc(61,"Populating Stores"),a.Ob(),a.Pb(62,"p"),a.zc(63," When you create a store, you can pass a map containing all your key/value pairs. This will instantly create, populate and activate the store. However if you would like to perform this operation later on, you can do so by calling the "),a.Pb(64,"code",1),a.zc(65,"populateStore()"),a.Ob(),a.zc(66," method and passing in your values.\n"),a.Ob(),a.Pb(67,"p"),a.zc(68," When you use "),a.Pb(69,"code",1),a.zc(70,"myStore.populateStore(Map<K,V>)"),a.Ob(),a.zc(71,", your store will be marked as initialized. When a store is initialized, any actor inside your application that is waiting for that store to be ready (see below), will be notified and receive updates on any objects they are interested in.\n"),a.Ob(),a.Pb(72,"h3"),a.zc(73,"Populating 'MyObject' Store"),a.Ob(),a.Pb(74,"pre",3),a.Pb(75,"code",4),a.Jb(),a.zc(76,"// Populate store with initial state\nconst initialData: Map<string, MyObject> = new Map();\ninitialData.put('123', { message: 'pretty' });\ninitialData.put('456', { message: 'kitty' });\n\nmyStore.populateStore(initData);"),a.Qb(),a.Ob(),a.Ob(),a.Kb(77,"hr"),a.Pb(78,"h2"),a.zc(79,"Creating, Reading, Updating and Deleting objects from a Store"),a.Ob(),a.Pb(80,"p"),a.zc(81," Once you have a reference to a store, you can easily add, update and remove items from that store using the "),a.Pb(82,"code",1),a.zc(83,"put(), get()"),a.Ob(),a.zc(84," and "),a.Pb(85,"code",1),a.zc(86,"remove()"),a.Ob(),a.zc(87," methods on that store.\n"),a.Ob(),a.Pb(88,"p"),a.zc(89," One of the concepts to know about the store is that it uses a 'bring your own state change types' model, Batteries not included here. This means you can define your own state changes, beyond CRUD style events (if you want)\n"),a.Ob(),a.Pb(90,"h3"),a.zc(91,"Adding and removing stuff from 'MyObject' Store"),a.Ob(),a.Pb(92,"pre",3),a.Pb(93,"code",4),a.Jb(),a.zc(94,"// define our own state changes\nenum MyObjectState {\n    Added,\n    Changed,\n    Sleeping\n}\n\n// add new object\nmyStore.put('789', { message: 'happy' }, MyObjectState.Added);\n\n// replace object\nmyStore.put('789', { message: 'puppy' }, MyObjectState.Changed);\n\n// delete object\nmyStore.remove('789', MyObjectState.Sleeping);"),a.Qb(),a.Ob(),a.Ob(),a.Pb(95,"h3"),a.zc(96,"Getting stuff from 'MyObject' Store"),a.Ob(),a.Pb(97,"pre",3),a.Pb(98,"code",4),a.Jb(),a.zc(99,"// Get single objects from store\nconst myObject_123: MyObject = myStore.get('123');\nconst myObject_456: MyObject = myStore.get('456');\n\n// get all objects from store\nconst myObjects: Array<MyObject> = myStore.allValues();\n\n// get all objects from a store as a map.\nconst myObjectsMap: Map<string, MyObject< = myStore.allValuesAsMap();"),a.Qb(),a.Ob(),a.Ob(),a.Kb(100,"hr"),a.Pb(101,"a",5),a.zc(102,"Next Steps: Store Advanced Use"),a.Ob())},directives:[s.b],styles:[""]}),e})(),j=(()=>{class e extends k.a{constructor(e){super("TransactionsComponent"),this.highlightService=e,this.highlighted=!1}ngOnInit(){}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(t){return new(t||e)(a.Ib(z.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-store-advanced"]],features:[a.tb],decls:125,vars:0,consts:[[1,"clr-code"],[1,"code"],[1,"language-typescript"],[1,"emphasis"],["role","alert",1,"alert","alert-info"],[1,"alert-items"],[1,"alert-item","static"],[1,"alert-icon-wrapper"],["shape","info-circle",1,"alert-icon"],[1,"alert-text"],["routerLink","/ts/iframes",1,"btn","btn-primary","btn-block","btn-outline"]],template:function(e,t){1&e&&(a.Pb(0,"h1"),a.zc(1,"Stores and Advanced use"),a.Ob(),a.Pb(2,"p"),a.zc(3," It's not really advanced, but you know, a little more functionality that just a map of maps. Stores can be subscribed to for state changes and initializations, as well as delegate mutation requests to business logic that handles API calls to mutate those models.\n"),a.Ob(),a.Pb(4,"p"),a.zc(5," Let's first start with understanding how I can be notified when state in a store has changed.\n"),a.Ob(),a.Kb(6,"hr"),a.Pb(7,"h2"),a.zc(8," Listening for state changes in a store.\n"),a.Ob(),a.Pb(9,"p"),a.zc(10," You can listen for any kind of state change on your store (state changes are defined by you), you can also listen for multiple state changes, not just a single one. You can decide to listen for an update to a single object, or all objects in the store.\n"),a.Ob(),a.Pb(11,"p"),a.zc(12," Two methods provide access to streams that can be subscribed to. The first one will tick any time any object is affected by any state change (you care about) in a store, this is "),a.Pb(13,"code",0),a.zc(14,"onAllChanges<S>(...stateChangeType: S[]): StoreStream<T>"),a.Ob(),a.Ob(),a.Pb(15,"p"),a.zc(16," The second one tick any time a specific object is affected by any state change (you care about) in a store, this is "),a.Pb(17,"code",0),a.zc(18,"onChange<S>(id: UUID, ...stateChangeType: S[]): StoreStream<T>"),a.Ob(),a.Ob(),a.Pb(19,"h3"),a.zc(20,"Listening for State Changes on 'MyObject' Store"),a.Ob(),a.Pb(21,"pre",1),a.Pb(22,"code",2),a.Jb(),a.zc(23,"// Listen for 'Added' state changes in 'myStore'\nmyStore.onAllChanges(MyObjectState.Added)\n    .subscribe(\n        (updatedObject: MyObject) => {\n            // do something interesting with this newly added thing.\n        }\n    );\n\n// Listen for 'Sleeping' and 'Changed' state changes in 'myStore'\nmyStore.onAllChanges(MyObjectState.Sleeping, MyObjectState.Changed)\n    .subscribe(\n        (updatedObject: MyObject) => {\n            // do something interesting with this changed or sleeping thing.\n        }\n    );"),a.Qb(),a.Ob(),a.Ob(),a.Pb(24,"p"),a.zc(25," You should notice that the return type of these methods is "),a.Pb(26,"code",0),a.zc(27,"StoreStream<T>"),a.Ob(),a.zc(28,". This interface provides you two simple methods: "),a.Pb(29,"code",0),a.zc(30,"subscribe(successHandler: MessageFunction<T>): Subscription"),a.Ob(),a.zc(31," and"),a.Pb(32,"code",0),a.zc(33,"unsubscribe(): void"),a.Ob(),a.zc(34,".\n"),a.Ob(),a.Pb(35,"p"),a.zc(36," Just like RxJS, this allows you subscribe to updates from the store for which ever object(s) you're interested in. You can also unsubscribe from the stream as well, when you no longer care about subscriptions. The return type of the "),a.Pb(37,"code",0),a.zc(38,"subscribe()"),a.Ob(),a.zc(39," method is an RxJS "),a.Pb(40,"code",0),a.zc(41,"Subscription"),a.Ob(),a.zc(42," object, which you can use at your leisure if you want.\n"),a.Ob(),a.Kb(43,"hr"),a.Pb(44,"h2"),a.zc(45,"Waiting for a store to be available - "),a.Pb(46,"span",3),a.zc(47,"dealing with race conditions"),a.Ob(),a.Ob(),a.Pb(48,"p"),a.zc(49," There are times when you need to ensure that components don't start pulling state from a store, before that store is ready. Normally you would define a process to bootstrap a store, populate it with data and then inform every consumer of that store, that the store is ready. There are a few ways to 'wait for a store to be ready'.\n"),a.Ob(),a.Pb(50,"h3"),a.zc(51,"Using "),a.Pb(52,"code",0),a.zc(53,"whenReady()"),a.Ob(),a.Ob(),a.Pb(54,"p"),a.zc(55," The first approach is to use the "),a.Pb(56,"code",0),a.zc(57,"myStore.whenReady(readyFunction: MessageFunction<Map<UUID, T>>)"),a.Ob(),a.zc(58," method. This allows you to pass a lambda in that will be passed the contents of the store when it's been 'initialized'. This will execute asynchronously. This is the simplest way to wait for a store's state to be set up before consuming it.\n"),a.Ob(),a.Pb(59,"h3"),a.zc(60,"Using whenReady() on 'myStore'"),a.Ob(),a.Pb(61,"pre",1),a.Pb(62,"code",2),a.Jb(),a.zc(63,"import { UUID } from '@vmw/transport';\n\n// Wait for store to be ready using whenReady();\nlet myData: Array<MyObject> = [];\n\nmyStore.whenReady(\n    (storeContents: Map<UUID, MyObject>) =>  {\n\n            // set myData.\n            myData = storeContents.values();\n        }\n    );\n\n...\n// ... somewhere else, initialize the store when it's loaded up.\nmyStore.initialize();"),a.Qb(),a.Ob(),a.Ob(),a.Pb(64,"div",4),a.Pb(65,"div",5),a.Pb(66,"div",6),a.Pb(67,"div",7),a.Kb(68,"clr-icon",8),a.Ob(),a.Pb(69,"span",9),a.zc(70," You can also use "),a.Pb(71,"code",0),a.zc(72,"myStore.populate()"),a.Ob(),a.zc(73," to initialize the store. When you use "),a.Pb(74,"code",0),a.zc(75,"populate()"),a.Ob(),a.zc(76,", the store is not only populated with bootstrapped state - it also initializes. Both will be broadcast to any consumer using "),a.Pb(77,"code",0),a.zc(78,"whenReady()"),a.Ob(),a.zc(79,". "),a.Ob(),a.Ob(),a.Ob(),a.Ob(),a.Kb(80,"hr"),a.Pb(81,"h3"),a.zc(82,"Using "),a.Pb(83,"code",0),a.zc(84,"readyJoin()"),a.Ob(),a.Pb(85,"span",3),a.zc(86," for multiple stores"),a.Ob(),a.Ob(),a.Pb(87,"p"),a.zc(88," The second approach is for when you need to wait for "),a.Pb(89,"strong"),a.zc(90,"multiple stores"),a.Ob(),a.zc(91," to be ready. This method is available via "),a.Pb(92,"code",0),a.zc(93,"this.storeManager"),a.Ob(),a.zc(94,". It's not attached to a particular store, as this functionality is designed to wait for multiple stores to be available. "),a.Pb(95,"code",0),a.zc(96,"this.storeManager.readyJoin(stores: Array<StoreType>): StoreReadyResult"),a.Ob(),a.zc(97," returns an object of type "),a.Pb(98,"code",0),a.zc(99,"StoreReadyResult"),a.Ob(),a.zc(100,".\n"),a.Ob(),a.Pb(101,"p"),a.zc(102," This interface provides the same method name as the store based approach as "),a.Pb(103,"code",0),a.zc(104,"whenReady()"),a.Ob(),a.zc(105,". Except this doesn't deliver the contents of a store to the handling function, as all stores are being waited on and the amount of data coming in could be significant.\n"),a.Ob(),a.Pb(106,"h3"),a.zc(107,"Using readyJoin() for multiple stores."),a.Ob(),a.Pb(108,"pre",1),a.Pb(109,"code",2),a.Jb(),a.zc(110,"// Create stores\nthis.storeManager.createStore('store1');\nthis.storeManager.createStore('store2');\nthis.storeManager.createStore('store3');\n\n// wait for all stores to be ready\nthis.storeManager.readyJoin(['store1', 'store2', 'store3'])\n        .whenReady(\n            () => {\n                // stores are ready... do something fun.\n            }\n        );\n\n// ... somewhere else, initialize stores.\nstore1.initialize();\nstore2.initialize();\nstore3.initialize();"),a.Qb(),a.Ob(),a.Ob(),a.Kb(111,"hr"),a.Pb(112,"h3"),a.zc(113,"Using Transactions "),a.Pb(114,"span",3),a.zc(115," - preferred approach for multiple stores"),a.Ob(),a.zc(116,"\xa0\u2728"),a.Ob(),a.Pb(117,"p"),a.zc(118," Transactions are the cleanest way to wait for multiple stores to be ready. You can combine requests/responses and waiting for stores to be ready into a single transaction.\n"),a.Ob(),a.Pb(119,"pre",1),a.Pb(120,"code",2),a.Jb(),a.zc(121,"// Create stores\nthis.storeManager.createStore<string>('store1');\nthis.storeManager.createStore<string>('store2');\nthis.storeManager.createStore<string>('store3');\n\n// create transaction.\nconst transaction: Transaction = this.bus.createTransaction();\n\n// register transaction complete handler.\ntransaction.onComplete(\n            (results: string[]) => {\n                    // do something with fun with your results.\n\n            }\n        );\n\n// register stores with transaction.\ntransaction.waitForStoreReady('store1');\ntransaction.waitForStoreReady('store2');\ntransaction.waitForStoreReady('store3');\n\n// commit transaction.\ntransaction.commit();\n\n// ... somewhere else, initialize stores.\nstore1.initialize();\nstore2.initialize();\nstore3.initialize();"),a.Qb(),a.Ob(),a.Ob(),a.Kb(122,"hr"),a.Pb(123,"a",10),a.zc(124,"Next Steps: Messaging Across iFrames"),a.Ob())},directives:[r.d,r.b,s.b],styles:[""]}),e})();var K=n("D9KC");let U=(()=>{class e extends k.a{constructor(e){super("TsDistributedIframesComponent"),this.highlightService=e,this.highlighted=!1}ngOnInit(){this.proxyControl=this.bus.enableMessageProxy({protectedChannels:["chatty-chat"],proxyType:K.ProxyType.Parent,parentOrigin:"https://vmware.github.io",acceptedOrigins:["http://localhost:4200","https://vmware.github.io"],targetAllFrames:!0,targetSpecificFrames:null}),this.chatStream=this.bus.listenStream("chatty-chat"),this.chatStream.handle(()=>{})}ngOnDestroy(){this.chatStream.close(),this.proxyControl.stopListening()}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(t){return new(t||e)(a.Ib(z.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-iframes"]],features:[a.tb],decls:77,vars:0,consts:[[1,"emphasis"],[1,"clr-row","chatty-demo-container"],[1,"clr-col-4"],[1,"sample-container"],["scrolling","no","src",a.Ec("/transport/iframe-demo")],["role","alert",1,"alert","alert-info"],[1,"alert-items"],[1,"alert-item","static"],[1,"alert-icon-wrapper"],["shape","info-circle",1,"alert-icon"],[1,"alert-text"],[1,"clr-code"],[1,"code"],[1,"language-typescript"],["href","https://github.com/vmware/transport-typescript/blob/master/src/proxy/message.proxy.api.ts"],["routerLink","/ts/abstractions",1,"btn","btn-primary","btn-block","btn-outline"]],template:function(e,t){1&e&&(a.Pb(0,"h1"),a.zc(1,"Creating a distributed bus across iFrames"),a.Ob(),a.Pb(2,"p"),a.zc(3," The bus has the capability to connect up event bus instances running inside child applications. This allows a third party application that is also using Transport to connect to the parent / master event bus. This allows the child application to talk to services in the parent UI, or even open connections to brokers and tap directly into live streams.\n"),a.Ob(),a.Pb(4,"p"),a.zc(5," You have the ability to control which origins are allowed to join the distributed bus, also which channels are authorized to be exposed across the distributed bus. This ensures that channels can be restricted across applications. You can also configure which iFrames are authorized to allow the bus instances to be connected.\n"),a.Ob(),a.Kb(6,"hr"),a.Pb(7,"h2"),a.zc(8," Talking across applications in iFrames.\n"),a.Ob(),a.Pb(9,"p"),a.zc(10," Here we have three iframes, inside each iframe is an instance of this same application, but we have loaded a demo component into each iframe. This will give us a total of 4 independent instances of Transport, One for each iframe and one that is running in this application, hosting the three iframes.\n"),a.Ob(),a.Pb(11,"p"),a.zc(12," There is only a single channel that they care about. This is a channel we named "),a.Pb(13,"span",0),a.zc(14,"'chatty-chat'"),a.Ob(),a.zc(15,". Transport has been bridged between the three iframes and the main application. This means they can all talk on the "),a.Pb(16,"span",0),a.zc(17,"'chatty-chat'"),a.Ob(),a.zc(18," channel, as if each separate application was running on the same event bus.\n"),a.Ob(),a.Kb(19,"br"),a.Pb(20,"div",1),a.Pb(21,"div",2),a.Pb(22,"section",3),a.Pb(23,"h3"),a.zc(24,"iFrame A"),a.Ob(),a.Kb(25,"iframe",4),a.Ob(),a.Ob(),a.Pb(26,"div",2),a.Pb(27,"section",3),a.Pb(28,"h3"),a.zc(29,"iFrame B"),a.Ob(),a.Kb(30,"iframe",4),a.Ob(),a.Ob(),a.Pb(31,"div",2),a.Pb(32,"section",3),a.Pb(33,"h3"),a.zc(34,"iFrame C"),a.Ob(),a.Kb(35,"iframe",4),a.Ob(),a.Ob(),a.Ob(),a.Pb(36,"div",5),a.Pb(37,"div",6),a.Pb(38,"div",7),a.Pb(39,"div",8),a.Kb(40,"clr-icon",9),a.Ob(),a.Pb(41,"span",10),a.zc(42," In the demo above, the same application is loaded three times, all in separate iframes. They are all talking on individual instances of Transport, that have all been bridged together, to form a distributed bus. iFrames are essentially sandboxed applications that make it quite difficult to talk to and from. There is a very limited messaging API via "),a.Pb(43,"code",11),a.zc(44,"window.postMessage()"),a.Ob(),a.zc(45," that allows parent and child applications to communicate, Transport uses this extensively to distribute streams. "),a.Ob(),a.Ob(),a.Ob(),a.Ob(),a.Kb(46,"hr"),a.Pb(47,"h3"),a.zc(48,"The Parent (Main Application)"),a.Ob(),a.Pb(49,"p"),a.zc(50," With this extensibility design, there will always be a parent application and child applications. The parent is the shell or containing application, it would provide shared infrastructure to any child application. Child applications are applications loaded inside iframes, or in a ShadowDOM that is sandboxed.\n"),a.Ob(),a.Pb(51,"p"),a.zc(52," This means a child application is completely isolated from the parent application. The parent cannot reach into down into its children and the child cannot reach back up to the parent.\n"),a.Ob(),a.Pb(53,"h3"),a.zc(54,"Chatty Chat Parent"),a.Ob(),a.Pb(55,"pre",12),a.Pb(56,"code",13),a.Jb(),a.zc(57,'@Component( {\n    selector: \'chatty-chat-app\',\n    template: ` <div class="clr-row chatty-demo-container" >\n     <div class="clr-col-4" >\n         <section class="sample-container" >\n             <h3 >iFrame A </h3 >\n             <iframe scrolling="no" src="/chatty-chat" > </iframe >\n         </section >\n     </div >\n     <div class="clr-col-4" >\n         <section class="sample-container" >\n             <h3 >iFrame B </h3 >\n             <iframe scrolling="no" src="/chatty-chat" > </iframe >\n         </section >\n     </div >\n     <div class="clr-col-4" >\n         <section class="sample-container" >\n             <h3 >iFrame C </h3 >\n             <iframe scrolling="no" src="/chatty-chat" > </iframe >\n         </section >\n     </div >`\n })\nexport class ChattyChatParent extends AbstractBase implements OnInit  {\n\n    constructor()  {\n        super(\'ChattyChatParent\');\n     }\n\n    ngOnInit()  {\n        // enable bus message proxy (enable distributed event bus mode)\n        this.bus.enableMessageProxy( {\n            protectedChannels: [\'chatty-chat\'],\n            proxyType: ProxyType.Parent,                    // runs as parent\n            parentOrigin: `https://github.com`,\n            acceptedOrigins: [\n                \'http://localhost:4200\',                    // local dev\n                \'https://github.com\'],             // production\n            targetAllFrames: true,\n            targetSpecificFrames: null,\n         });\n\n        // ensure we open the chatty chat channel, to ensure messages are not dropped.\n        // we don\'t however care about doing anything with the traffic on the stream here.\n        this.bus.listenStream(\'chatty-chat\')\n            .handle(() = >  {\n             }); // do nothing, just ensure the channel is open.\n     }\n }'),a.Qb(),a.Ob(),a.Ob(),a.Kb(58,"hr"),a.Pb(59,"h3"),a.zc(60,"Chatty Chat Child"),a.Ob(),a.Pb(61,"pre",12),a.Pb(62,"code",13),a.Jb(),a.zc(63,"@Component({\n    selector: 'chatty-chat-child',\n    template: `<section class=\"chat-container\">\n        <div class=\"message-label\">\n            Messages Received\n        </div>\n        <div [ngClass]=\"{ 'message-count': true, flash: flash}\">\n            {{messageCount}}\n        </div>\n        <div class=\"broadcast\">\n            <button (click)=\"sendChat()\" class=\"btn btn-primary-outline\" [disabled]=\"buttonDisabled\">\n                Broadcast Something\n            </button>\n        </div>\n    </section>`\n})\nexport class ChattyChatChildApp extends AbstractBase implements OnInit {\n\n    public messageCount = 0;\n    public flash = false;\n    public buttonDisabled = false;\n\n    constructor() {\n        super('ChattyChatComponent');\n    }\n\n    ngOnInit(): void {\n        // enable message proxy.\n        this.bus.enableMessageProxy({\n            protectedChannels: ['chatty-chat'],\n            proxyType: ProxyType.Child,                     // runs as child.\n            parentOrigin: `https://github.com`,\n            acceptedOrigins: [\n                'http://localhost:4200',                    // local dev\n                'https://github.com'],             // production\n            targetAllFrames: true,\n            targetSpecificFrames: null,\n        });\n\n        // listen to chatty chat, increment message count for every message that comes in.\n        this.bus.listenStream('chatty-chat')\n            .handle(\n                () => {\n                    // increase message count.\n                    this.messageCount++;\n\n                    // flash message\n                    this.flash = true;\n\n                    // wait a second then remove flash and re-enable button\n                    this.bus.api.tickEventLoop(\n                        () => {\n                            this.buttonDisabled = false;\n                            this.flash = false;\n                        }, 1000\n                    );\n                }\n            );\n    }\n\n    sendChat(): void {\n        if (!this.buttonDisabled) {\n            // disable button.\n            this.buttonDisabled = true;\n\n            // send an empty message to chatty-chat.\n            this.bus.sendResponseMessage('chatty-chat', {});\n        }\n    }\n}"),a.Qb(),a.Ob(),a.Ob(),a.Kb(64,"hr"),a.Pb(65,"div",5),a.Pb(66,"div",6),a.Pb(67,"div",7),a.Pb(68,"div",8),a.Kb(69,"clr-icon",9),a.Ob(),a.Pb(70,"span",10),a.Pb(71,"a",14),a.zc(72,"You can take a look at the API"),a.Ob(),a.zc(73," if you'd like to know more. "),a.Ob(),a.Ob(),a.Ob(),a.Ob(),a.Kb(74,"hr"),a.Pb(75,"a",15),a.zc(76,"Next Steps: Abstractions"),a.Ob())},directives:[r.d,r.b,s.b],styles:[".sample-container[_ngcontent-%COMP%]{border:none;max-height:none;display:block;overflow-x:auto;padding:.9em;color:#abb2bf;background:#0e161b;border-radius:10px;border-color:#0a0a14 #170f29 #332e40 #131020;border-style:solid;border-width:1px;font-size:.9em}.sample-container[_ngcontent-%COMP%]   h3[_ngcontent-%COMP%]{text-align:center;margin-top:0;margin-bottom:15px}iframe[_ngcontent-%COMP%]{width:100%;min-height:300px;overflow:hidden;border-radius:10px;border:2px dashed #2e404a;padding:10px}.chatty-demo-container[_ngcontent-%COMP%]{margin-bottom:20px}"]}),e})(),D=(()=>{class e extends k.a{constructor(e){super("AbstractionsComponent"),this.highlightService=e,this.highlighted=!1}ngOnInit(){}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(t){return new(t||e)(a.Ib(z.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-abstractions"]],features:[a.tb],decls:150,vars:0,consts:[["id","abstractcore"],[1,"clr-code"],[1,"emphasis"],[1,"code"],[1,"language-typescript"],[1,"list"],["href","https://github.com/vmware/transport-typescript/blob/master/src/core/abstractions/abstract.core.ts","target","_blank"],["id","abstractbase"],["id","abstractservice"]],template:function(e,t){1&e&&(a.Pb(0,"h1"),a.zc(1,"Using Transport via built in abstractions"),a.Ob(),a.Pb(2,"p"),a.zc(3," There are a number of core abstractions provided that hide and encapsulate boilerplate and bus logic, as well as standardize designs and patterns across applications. These abstractions vary for different use cases and different needs.\n"),a.Ob(),a.Pb(4,"p"),a.zc(5," Extending from the provided abstractions cleanly encapsulates essential properties that every actor will require.\n"),a.Ob(),a.Kb(6,"hr"),a.Pb(7,"h3",0),a.zc(8,"Using "),a.Pb(9,"code",1),a.zc(10,"AbstractCore"),a.Ob(),a.zc(11," - "),a.Pb(12,"span",2),a.zc(13,"lowest level access"),a.Ob(),a.Ob(),a.Pb(14,"p"),a.Pb(15,"code",1),a.zc(16,"AbstractCore"),a.Ob(),a.zc(17," provides access to four essential properties to all subclasses. It can imported into your code from "),a.Pb(18,"code",1),a.zc(19,"@vmw/transport/core"),a.Ob(),a.zc(20,".\n"),a.Ob(),a.Pb(21,"pre",3),a.Pb(22,"code",4),a.Jb(),a.zc(23,"import { AbstractCore } from '@vmw/transport/core';"),a.Qb(),a.Ob(),a.Ob(),a.Pb(24,"ul",5),a.Pb(25,"li"),a.Pb(26,"code",1),a.zc(27,"this.bus"),a.Ob(),a.zc(28," - "),a.Pb(29,"span",2),a.zc(30,"Access to the global event bus"),a.Ob(),a.Ob(),a.Pb(31,"li"),a.Pb(32,"code",1),a.zc(33,"this.storeManager"),a.Ob(),a.zc(34," - "),a.Pb(35,"span",2),a.zc(36,"Access to global store manager"),a.Ob(),a.Ob(),a.Pb(37,"li"),a.Pb(38,"code",1),a.zc(39,"this.log"),a.Ob(),a.zc(40," - "),a.Pb(41,"span",2),a.zc(42,"Access to logging."),a.Ob(),a.Ob(),a.Pb(43,"li"),a.Pb(44,"code",1),a.zc(45,"this.fabric"),a.Ob(),a.zc(46," - "),a.Pb(47,"span",2),a.zc(48,"Access to Fabric APIs (alpha)"),a.Ob(),a.Ob(),a.Ob(),a.Pb(49,"p"),a.Pb(50,"code",1),a.zc(51,"AbstractCore"),a.Ob(),a.zc(52," is actually quite basic, You can see the code at: "),a.Pb(53,"a",6),a.zc(54," https://github.com/vmware/transport-typescript/blob/master/src/core/abstractions/abstract.core.ts "),a.Ob(),a.Ob(),a.Pb(55,"p"),a.zc(56," To use "),a.Pb(57,"code",1),a.zc(58,"AbstractCore"),a.Ob(),a.zc(59,", simply extend your class from it, like the following example.\n"),a.Ob(),a.Pb(60,"pre",3),a.Pb(61,"code",4),a.Jb(),a.zc(62,"\nimport { AbstractCore } from '@vmw/transport/core';\n\nexport class MyClass extends AbstractCore {\n    constructor() {\n        // ...now you have access to this.bus, this.storeManager and this.log\n    }\n}\n"),a.Qb(),a.Ob(),a.zc(63,"\n"),a.Ob(),a.Pb(64,"p"),a.Pb(65,"code",1),a.zc(66,"AbstractCore"),a.Ob(),a.zc(67," is useful, but there is preferred Abstraction to use. "),a.Pb(68,"strong",2),a.zc(69,"AbstractBase"),a.Ob(),a.Ob(),a.Kb(70,"hr"),a.Pb(71,"h3",7),a.zc(72,"Using "),a.Pb(73,"code",1),a.zc(74,"AbstractBase"),a.Ob(),a.zc(75," - "),a.Pb(76,"span",2),a.zc(77,"recommended"),a.Ob(),a.zc(78,"\xa0\u2728"),a.Ob(),a.Pb(79,"p"),a.Pb(80,"code",1),a.zc(81,"AbstractBase"),a.Ob(),a.zc(82," extends "),a.Pb(83,"code",1),a.zc(84,"AbstractCore"),a.Ob(),a.zc(85,", so it not only has access to low level objects, it provides some higher level functionality. This class provides access to global operations.\n"),a.Ob(),a.Pb(86,"p"),a.Pb(87,"code",1),a.zc(88,"AbstractBase"),a.Ob(),a.zc(89," is where all feature abstractions are added, so if you want to access new stuff for free? This is the abstraction you want.\n"),a.Ob(),a.Pb(90,"p"),a.zc(91," To use "),a.Pb(92,"code",1),a.zc(93,"AbstractBase"),a.Ob(),a.zc(94,", simply extend your class from it, like the following example.\n"),a.Ob(),a.Pb(95,"pre",3),a.Pb(96,"code",4),a.Jb(),a.zc(97,"\nimport { AbstractBase } from '@vmw/transport/core';\n\nexport class MyClass extends AbstractBase {\n    constructor() {\n        super('MyClass'); // AbstractBase requires a constructor arg\n                          // of the name of the class, used for logging purposes.\n\n        // ...now you have access to this.bus, this.storeManager and this.log\n    }\n}\n"),a.Qb(),a.Ob(),a.zc(98,"\n"),a.Ob(),a.Pb(99,"p"),a.zc(100," This should be all you would ever need. There is another abstraction for building services however.\n"),a.Ob(),a.Kb(101,"hr"),a.Pb(102,"h3",8),a.zc(103,"Using "),a.Pb(104,"code",1),a.zc(105,"AbstractService"),a.Ob(),a.zc(106," - foundation for services"),a.Ob(),a.Pb(107,"p"),a.Pb(108,"code",1),a.zc(109,"AbstractService"),a.Ob(),a.zc(110," extends "),a.Pb(111,"code",1),a.zc(112,"AbstractBase"),a.Ob(),a.zc(113,". It encapsulates logic required to handle and process inbound requests on a channel, and issue responses. "),a.Ob(),a.Pb(114,"p"),a.Pb(115,"code",1),a.zc(116,"AbstractService"),a.Ob(),a.zc(117," employs generics to define the request object type and response object type it employs.\n"),a.Ob(),a.Kb(118,"p"),a.Pb(119,"p"),a.zc(120," There is a single contracted method that an implementing class must provide a concrete method for. This method is "),a.Pb(121,"code",1),a.zc(122,"handleServiceRequest(request: ReqT)"),a.Ob(),a.zc(123,". A service will implement the logic required to handle any requests being made on the channel\n"),a.Ob(),a.Pb(124,"p"),a.zc(125," The whole purpose of a service, is to encapsulate business logic that performs complex (non-rendering) tasks, or talks to infrastructure to read, query or mutate state. A few good examples of services would be crunching numbers & formulas, parsing and validating objects or JSON, marshaling and un-marshaling data to and from DTO's, calling API's etc.\n"),a.Ob(),a.Pb(126,"p"),a.zc(127," The key benefit to "),a.Pb(128,"strong"),a.zc(129,"*not*"),a.Ob(),a.zc(130," using a third party vendor framework for handling services, is that the service and the logic it contains becomes 100% decoupled from that framework and can be ported across UI's and technology stacks. Another key benefit, is that the service can be "),a.Pb(131,"strong"),a.zc(132,"pushed down the stack"),a.Ob(),a.zc(133," and out of the browser using the fabric.\n"),a.Ob(),a.Pb(134,"p"),a.zc(135," To use "),a.Pb(136,"code",1),a.zc(137,"AbstractService"),a.Ob(),a.zc(138,", simply extend your class from it and provide your own implementation of "),a.Pb(139,"code",1),a.zc(140,"handleServiceRequest(request: ReqT)"),a.Ob(),a.zc(141,". The following sample demonstrates what this looks like.\n"),a.Ob(),a.Pb(142,"h3"),a.zc(143,"Example Service"),a.Ob(),a.Pb(144,"pre",3),a.Pb(145,"code",4),a.Jb(),a.zc(146,"\nimport { AbstractService } from '@vmw/transport/core';\n\nexport class MyRequest {\n    public payload: any;\n}\n\nexport class MyResponse {\n    public payload: any;\n}\n\n\nexport class MyService extends AbstractService<MyRequest, MyResponse> {\n    constructor() {\n        super('MyService', 'service-channel'); // the second argument defines\n                                               // the channel in which the service listens on.\n    }\n\n    protected handleServiceRequest(request: MyRequest): void {\n\n        // ...do what ever you need to do with this request.\n        // ...when you're done, you would return your response\n        // ...to the requesting actor by this.postResponse(channel, response);\n\n        const myResponse: MyResponse = new MyResponse({payload: 'anything'});\n        this.postResponse('service-channel', myResponse);\n\n    }\n\n}\n"),a.Qb(),a.Ob(),a.zc(147,"\n"),a.Ob(),a.Pb(148,"p"),a.zc(149," Your request/responses can be of your own design. You don't need a 'payload' property. This is just for illustration purposes.\n"),a.Ob())},styles:[""]}),e})(),F=(()=>{class e{constructor(e){this.highlightService=e,this.highlighted=!1}ngOnInit(){}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(t){return new(t||e)(a.Ib(z.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-importing-angular"]],decls:55,vars:4,consts:[[3,"inputCommand","consoleTheme","loopAnimation","disableAnimation"],[1,"clr-code"],[1,"code"],[1,"language-json"],["routerLink","../initializing"],[1,"language-js"],["href","https://stackblitz.com/edit/angular-jxca5i"],["src",a.Ec("https://stackblitz.com/edit/angular-jxca5i?ctl=1&embed=1&file=src/main.ts"),1,"stackblitz"],["routerLink","/ts/initializing",1,"btn","btn-primary","btn-block","btn-outline"]],template:function(e,t){1&e&&(a.Pb(0,"h1"),a.zc(1,"Importing Transport for TypeScript into Angular Applications"),a.Ob(),a.Pb(2,"p"),a.zc(3," Make sure you install transport first. Package is available via npm.\n"),a.Ob(),a.Kb(4,"br"),a.Kb(5,"transport-animated-console",0),a.Kb(6,"hr"),a.Kb(7,"h2"),a.Pb(8,"p"),a.zc(9," Angular provides "),a.Pb(10,"code",1),a.zc(11,"angular.json"),a.Ob(),a.zc(12," (for Angular 7+) and "),a.Pb(13,"code",1),a.zc(14,"angular-cli.json"),a.Ob(),a.zc(15," (for Angular 4-5).\n"),a.Ob(),a.Pb(16,"h4"),a.zc(17,"Configuring "),a.Pb(18,"code",1),a.zc(19,"angular.json"),a.Ob(),a.Ob(),a.Pb(20,"p"),a.zc(21," You need to add "),a.Pb(22,"code",1),a.zc(23,"@vmw/transport"),a.Ob(),a.zc(24," to the "),a.Pb(25,"code",1),a.zc(26,"allowedCommonJsDependencies"),a.Ob(),a.zc(27," option that is a part of "),a.Pb(28,"code",1),a.zc(29,"architect/build/options"),a.Ob(),a.zc(30," property in your "),a.Pb(31,"code",1),a.zc(32,"angular.json"),a.Ob(),a.Ob(),a.Pb(33,"pre",2),a.Pb(34,"code",3),a.Jb(),a.zc(35,'...\n "allowedCommonJsDependencies": ["@vmw/transport"],\n...'),a.Qb(),a.Ob(),a.Ob(),a.Pb(36,"p"),a.zc(37," Your application is ready to go, now you just need to boot transport\n"),a.Ob(),a.Pb(38,"p"),a.zc(39," Angular provides a "),a.Pb(40,"code",1),a.zc(41,"src/main.ts"),a.Ob(),a.zc(42," file, which is essentially your initialization script, that you can use to "),a.Pb(43,"a",4),a.zc(44,"Initialize the Bus."),a.Ob(),a.Ob(),a.Pb(45,"pre",2),a.Pb(46,"code",5),a.zc(47,'import {BusUtil} from "@vmw/transport/util/bus.util";\nimport {LogLevel} from "@vmw/transport/log";\n\nBusUtil.bootBus();\n'),a.Ob(),a.Ob(),a.Pb(48,"h4"),a.Pb(49,"a",6),a.zc(50,"Try it out in StackBlitz"),a.Ob(),a.Ob(),a.Kb(51,"iframe",7),a.Kb(52,"hr"),a.Pb(53,"a",8),a.zc(54,"Next Steps: Initializing Transport"),a.Ob()),2&e&&(a.wb(5),a.gc("inputCommand","npm install @vmw/transport --save")("consoleTheme","macOS")("loopAnimation",!1)("disableAnimation",!0))},directives:[O.a,s.b],styles:[""]}),e})(),E=(()=>{class e{constructor(e){this.highlightService=e,this.highlighted=!1}ngOnInit(){}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(t){return new(t||e)(a.Ib(z.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-importing-react"]],decls:28,vars:4,consts:[[3,"inputCommand","consoleTheme","loopAnimation","disableAnimation"],["routerLink","../importing"],[1,"code"],[1,"language-js"],["href","https://stackblitz.com/edit/react-ts-zfats4?file=index.tsx"],["src",a.Ec("https://stackblitz.com/edit/react-ts-zfats4?ctl=1&embed=1&file=index.tsx"),1,"stackblitz"],[1,"language-typescript"],["routerLink","/ts/initializing",1,"btn","btn-primary","btn-block","btn-outline"]],template:function(e,t){1&e&&(a.Pb(0,"h1"),a.zc(1,"Importing Transport for TypeScript into React Applications"),a.Ob(),a.Pb(2,"p"),a.zc(3," Make sure you install transport first. Package is available via npm.\n"),a.Ob(),a.Kb(4,"br"),a.Kb(5,"transport-animated-console",0),a.Kb(6,"hr"),a.Kb(7,"h2"),a.Pb(8,"p"),a.zc(9," React is really simple, it's as simple as "),a.Pb(10,"a",1),a.zc(11,"importing ES6"),a.Ob(),a.zc(12,".\n"),a.Ob(),a.Pb(13,"pre",2),a.Pb(14,"code",3),a.zc(15,"import React, { Component } from 'react';\nimport { render } from 'react-dom';\nimport { BusUtil } from '@vmw/transport/util/bus.util';\n\ninterface AppProps {}\ninterface AppState {\n    id: string;\n}\n\nclass App extends Component<AppProps, AppState> {\n    constructor(props) {\n    super(props);\n\n    // boot the bus\n    BusUtil.bootBus();\n\n    // capture instance of the bus.\n    const bus = BusUtil.getBusInstance();\n\n    // set state.\n    this.state = {\n        id: bus.api.getId()\n    };\n  }\n\n  render() {\n    return (\n      <div>\n        <Hello id={this.state.id} /=>\n      </div>\n    );\n  }\n}\nrender(<App />, document.getElementById('root'));\n"),a.Ob(),a.Ob(),a.Pb(16,"h4"),a.Pb(17,"a",4),a.zc(18,"Try it out in StackBlitz"),a.Ob(),a.Ob(),a.Kb(19,"iframe",5),a.Kb(20,"hr"),a.Pb(21,"h2"),a.zc(22,"Using a Provider to access Transport"),a.Ob(),a.Pb(23,"pre",2),a.Pb(24,"code",6),a.Jb(),a.zc(25,"import React, { useContext } from 'react';\nimport { AbstractCore } from '@vmw/transport/core';\n\nexport class Transport extends AbstractCore {}\nexport const TransportContext = React.createContext<any>(null);\n\ninterface ProviderProps extends React.Props {\n    transport: Transport;\n}\n\nexport const Provider: React.FC<ProviderProps> = props => (\n  <TransportContext.Provider value={props.transport}>\n    {props.children}\n  </TransportContext.Provider>\n);\n\nexport const useTransport = () => useContext(TransportContext);\n"),a.Qb(),a.Ob(),a.Ob(),a.Pb(26,"a",7),a.zc(27,"Next Steps: Initializing Transport"),a.Ob()),2&e&&(a.wb(5),a.gc("inputCommand","npm install @vmw/transport --save")("consoleTheme","macOS")("loopAnimation",!1)("disableAnimation",!0))},directives:[O.a,s.b],styles:[""]}),e})();const J=[{path:"",component:g,children:[{path:"",component:f},{path:"overview",component:f},{path:"importing",component:v},{path:"importing-angular",component:F},{path:"importing-umd",component:(()=>{class e{constructor(e){this.highlightService=e,this.highlighted=!1}ngOnInit(){}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(t){return new(t||e)(a.Ib(z.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-importing-umd"]],decls:36,vars:4,consts:[[3,"inputCommand","consoleTheme","loopAnimation","disableAnimation"],[1,"clr-code"],[1,"code"],[1,"language-js"],["href","https://stackblitz.com/edit/js-yfdlde?file=index.html"],["src",a.Ec("https://stackblitz.com/edit/js-yfdlde?ctl=1&embed=1&file=index.html&theme=dark"),1,"stackblitz"],[1,"language-typescript"],["routerLink","/ts/initializing",1,"btn","btn-primary","btn-block","btn-outline"]],template:function(e,t){1&e&&(a.Pb(0,"h1"),a.zc(1,"Importing Transport for TypeScript via UMD"),a.Ob(),a.Pb(2,"p"),a.zc(3," Make sure you install transport first, Package is available via npm.\n"),a.Ob(),a.Kb(4,"br"),a.Kb(5,"transport-animated-console",0),a.Kb(6,"hr"),a.Pb(7,"h2"),a.zc(8,"UMD module import through the HTML "),a.Pb(9,"code",1),a.zc(10,"<script>"),a.Ob(),a.zc(11," tag"),a.Ob(),a.Pb(12,"p"),a.zc(13," If you would like to use Transport in a simple setup, say an HTML with WebComponents in it, you can import the UMD version of the library via a script tag. Note that RxJS is the only prerequisite for Transport so make sure to import it first.\n"),a.Ob(),a.Pb(14,"pre",2),a.Pb(15,"code",3),a.Jb(),a.zc(16,'<script src="https://cdn.jsdelivr.net/npm/rxjs@6.6.3/bundles/rxjs.umd.min.js"><\/script>\n<script src="https://cdn.jsdelivr.net/npm/@vmw/transport@latest/transport.umd.min.js"><\/script>\n<script>\n    // boot the event bus!\n    transport.TransportEventBus.boot();\n<\/script>\n'),a.Qb(),a.Ob(),a.Ob(),a.Pb(17,"h4"),a.Pb(18,"a",4),a.zc(19,"Try it out in StackBlitz"),a.Ob(),a.Ob(),a.Kb(20,"iframe",5),a.Kb(21,"hr"),a.Kb(22,"hr"),a.Pb(23,"h2"),a.zc(24,"Importing Transport in your code"),a.Ob(),a.Pb(25,"p"),a.zc(26," The main interface you will need is "),a.Pb(27,"code",1),a.zc(28,"EventBus"),a.Ob(),a.zc(29,". It provides access to the most common methods.\n"),a.Ob(),a.Pb(30,"pre",2),a.Pb(31,"code",6),a.Jb(),a.zc(32," import { EventBus } from '@vmw/transport';"),a.Qb(),a.Ob(),a.Ob(),a.Kb(33,"hr"),a.Pb(34,"a",7),a.zc(35,"Next Steps: Initializing Transport"),a.Ob()),2&e&&(a.wb(5),a.gc("inputCommand","npm install @vmw/transport --save")("consoleTheme","macOS")("loopAnimation",!1)("disableAnimation",!0))},directives:[O.a,s.b],styles:[""]}),e})()},{path:"importing-react",component:E},{path:"initializing",component:w},{path:"hello-world",component:S},{path:"building-services",component:T},{path:"calling-services",component:C},{path:"advanced-messaging",component:A},{path:"transactions",component:x},{path:"logging",component:I},{path:"broker-overview",component:q},{path:"connecting-broker",component:R},{path:"multiple-brokers",component:M},{path:"extending-channels",component:L},{path:"store-basics",component:B},{path:"store-advanced",component:j},{path:"iframes",component:U},{path:"abstractions",component:D}]}];let N=(()=>{class e{}return e.\u0275mod=a.Gb({type:e}),e.\u0275inj=a.Fb({factory:function(t){return new(t||e)},imports:[[s.c.forChild(J)],s.c]}),e})();var W=n("PCNd");let Q=(()=>{class e{}return e.\u0275mod=a.Gb({type:e}),e.\u0275inj=a.Fb({factory:function(t){return new(t||e)},imports:[[o.c,N,W.a,o.c,r.a]]}),e})()}}]);