(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{L83D:function(e,n,t){"use strict";t.r(n),t.d(n,"JavaModule",function(){return C});var r=t("ofXK"),s=t("tyNb"),a=t("fXoL"),o=t("8MG2"),i=t("320Y"),c=t("jQpT");const l=["mainContent"];function b(e,n){1&e&&(a.Pb(0,"clr-vertical-nav-group-children"),a.Pb(1,"a",8),a.zc(2," Importing Transport "),a.Ob(),a.Pb(3,"a",9),a.zc(4," Configuring Spring "),a.Ob(),a.Pb(5,"a",10),a.zc(6," Initializing Transport "),a.Ob(),a.Pb(7,"a",11),a.zc(8," Hello World! "),a.Ob(),a.Ob())}function p(e,n){1&e&&(a.Pb(0,"clr-vertical-nav-group-children"),a.Pb(1,"a",12),a.zc(2," Messaging Types "),a.Ob(),a.Pb(3,"a",13),a.zc(4," Building Services "),a.Ob(),a.Pb(5,"a",14),a.zc(6," Private Channels "),a.Ob(),a.Pb(7,"a",15),a.zc(8," Transactions "),a.Ob(),a.Pb(9,"a",16),a.zc(10," Logging "),a.Ob(),a.Ob())}function d(e,n){1&e&&(a.Pb(0,"clr-vertical-nav-group-children"),a.Pb(1,"a",17),a.zc(2," Calling RESTful APIs "),a.Ob(),a.Pb(3,"a",18),a.zc(4," Built in Abstractions "),a.Ob(),a.Ob())}let h=(()=>{class e{constructor(){}ngOnInit(){}onActivate(e){this.mainContentDiv&&(this.mainContentDiv.nativeElement.scrollTop=0)}}return e.\u0275fac=function(n){return new(n||e)},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-java"]],viewQuery:function(e,n){if(1&e&&a.Fc(l,!0),2&e){let e;a.lc(e=a.Yb())&&(n.mainContentDiv=e.first)}},decls:19,vars:5,consts:[[1,"content-container"],[3,"clrVerticalNavCollapsible","clr-nav-level"],["clrVerticalNavLink","","routerLink","./overview","routerLinkActive","active"],["routerLinkActive","active"],[4,"clrIfExpanded"],["id","main-content",1,"content-area"],["mainContent",""],[3,"activate"],["clrVerticalNavLink","","routerLink","./importing","routerLinkActive","active"],["clrVerticalNavLink","","routerLink","./configuring","routerLinkActive","active"],["clrVerticalNavLink","","routerLink","./initializing","routerLinkActive","active"],["clrVerticalNavLink","","routerLink","./hello-world","routerLinkActive","active"],["clrVerticalNavLink","","routerLink","./messaging","routerLinkActive","active"],["clrVerticalNavLink","","routerLink","./building-services","routerLinkActive","active"],["clrVerticalNavLink","","routerLink","./private-channels","routerLinkActive","active"],["clrVerticalNavLink","","routerLink","./transactions","routerLinkActive","active"],["clrVerticalNavLink","","routerLink","./logging","routerLinkActive","active"],["clrVerticalNavLink","","routerLink","./rest","routerLinkActive","active"],["clrVerticalNavLink","","routerLink","./abstractions","routerLinkActive","active"]],template:function(e,n){1&e&&(a.Pb(0,"clr-main-container"),a.Kb(1,"transport-header"),a.Pb(2,"div",0),a.Pb(3,"clr-vertical-nav",1),a.Pb(4,"a",2),a.zc(5," Java Overview "),a.Ob(),a.Pb(6,"clr-vertical-nav-group",3),a.zc(7," Getting Started "),a.xc(8,b,9,0,"clr-vertical-nav-group-children",4),a.Ob(),a.Pb(9,"clr-vertical-nav-group",3),a.zc(10," Operations "),a.xc(11,p,11,0,"clr-vertical-nav-group-children",4),a.Ob(),a.Pb(12,"clr-vertical-nav-group",3),a.zc(13," Utilities "),a.xc(14,d,5,0,"clr-vertical-nav-group-children",4),a.Ob(),a.Ob(),a.Pb(15,"div",5,6),a.Pb(17,"router-outlet",7),a.Xb("activate",function(e){return n.onActivate(e)}),a.Ob(),a.Ob(),a.Ob(),a.Kb(18,"transport-footer"),a.Ob()),2&e&&(a.wb(3),a.gc("clrVerticalNavCollapsible",!1)("clr-nav-level",2),a.wb(5),a.gc("clrIfExpanded",!0),a.wb(3),a.gc("clrIfExpanded",!0),a.wb(3),a.gc("clrIfExpanded",!0))},directives:[o.f,o.p,i.a,o.l,o.g,s.b,o.o,s.a,o.m,o.s,o.e,s.d,c.a,o.n],styles:["clr-vertical-nav-group[_ngcontent-%COMP%]{margin-top:10px;margin-bottom:10px}.content-area[_ngcontent-%COMP%]{padding:20px}"]}),e})();var u=t("w7eE"),g=t("QOlJ"),m=t("SrJx"),v=t("CyPm");function f(e,n){if(1&e&&(a.Pb(0,"section"),a.Pb(1,"h4",11),a.zc(2),a.Ob(),a.Kb(3,"transport-animated-console",12),a.Ob()),2&e){const e=n.$implicit,t=n.index;a.wb(2),a.Ac(e.title),a.wb(1),a.gc("inputCommand",e.command)("helperTxt",e.notes)("consoleTheme","macOS")("loopAnimation",!1)("delay",1e3*t)}}let P=(()=>{class e extends u.a{constructor(e){super("OverviewComponent"),this.highlightService=e,this.highlighted=!1}highlight(){this.highlightService.highlightAll()}ngOnInit(){this.javaCommands=g.b}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(n){return new(n||e)(a.Ib(m.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-overview"]],features:[a.tb],decls:23,vars:1,consts:[["src","assets/github.png","alt","github","title","transport on github",1,"github-logo"],["href","https://github.com/vmware/transport-java"],["role","alert",1,"alert","alert-info"],[1,"alert-items"],[1,"alert-item","static"],[1,"alert-icon-wrapper"],["shape","exclamation-circle",1,"alert-icon"],[1,"alert-text"],["href","https://spring.io/projects/spring-framework"],[4,"ngFor","ngForOf"],["routerLink","/java/importing",1,"btn","btn-primary","btn-block","btn-outline"],[1,"code-step"],[3,"inputCommand","helperTxt","consoleTheme","loopAnimation","delay"]],template:function(e,n){1&e&&(a.Pb(0,"h1"),a.zc(1,"Transport for Java"),a.Ob(),a.Kb(2,"img",0),a.Pb(3,"a",1),a.zc(4,"View Java source on Github"),a.Ob(),a.Kb(5,"br"),a.Kb(6,"br"),a.Pb(7,"div",2),a.Pb(8,"div",3),a.Pb(9,"div",4),a.Pb(10,"div",5),a.Kb(11,"clr-icon",6),a.Ob(),a.Pb(12,"span",7),a.zc(13," We're still working on these docs. "),a.Ob(),a.Ob(),a.Ob(),a.Ob(),a.Pb(14,"p"),a.zc(15," This implementation is written in Java and depends on the "),a.Pb(16,"a",8),a.zc(17,"Spring Framework"),a.Ob(),a.zc(18,", because it's awesome.\n"),a.Ob(),a.xc(19,f,4,6,"section",9),a.Kb(20,"hr"),a.Pb(21,"a",10),a.zc(22,"Next Steps: Importing Transport"),a.Ob()),2&e&&(a.wb(19),a.gc("ngForOf",n.javaCommands))},directives:[o.d,o.b,r.m,s.b,v.a],styles:[""]}),e})(),z=(()=>{class e{constructor(e){this.highlightService=e,this.highlighted=!1}ngOnInit(){}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(n){return new(n||e)(a.Ib(m.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-importing"]],decls:26,vars:0,consts:[[1,"code"],[1,"language-typescript"],[1,"language-markup"],["routerLink","/java/initializing",1,"btn","btn-primary","btn-block","btn-outline"]],template:function(e,n){1&e&&(a.Pb(0,"h1"),a.zc(1,"Importing Transport into your Spring Application"),a.Ob(),a.Pb(2,"p"),a.zc(3," The Java version of Transport can be consumed via gradle, or maven.\n"),a.Ob(),a.Pb(4,"h3"),a.zc(5,"What does the Transport depend on?"),a.Ob(),a.Pb(6,"p"),a.zc(7," Magic doesn't come for free, so Transport heavily depends on RxJava, Spring, Jackson, Apache Commons and a few others.\n"),a.Ob(),a.Kb(8,"hr"),a.Pb(9,"h3"),a.zc(10,"Configuring Gradle"),a.Ob(),a.Pb(11,"p"),a.zc(12," Add a dependency to the desired Transport jar version and its dependencies.\n"),a.Ob(),a.Pb(13,"pre",0),a.Pb(14,"code",1),a.Jb(),a.zc(15,'dependencies {\n    compile "com.vmware.transport:vmw-transport:1.0.0"\n    compile "org.springframework.boot:spring-boot-starter-web:1.5.18.RELEASE"\n    compile "org.springframework.boot:spring-boot-starter-websocket:1.5.18.RELEASE"\n    compile "org.springframework.security:spring-security-web:4.2.2.RELEASE"\n    compile "org.springframework.security:spring-security-config:4.2.2.RELEASE"\n    compile "io.reactivex.rxjava2:rxjava:2.1.9"\n    compile "com.fasterxml.jackson.core:jackson-databind:2.9.4"\n    compile "com.fasterxml.jackson.module:jackson-module-jsonSchema:2.9.4"\n    compile "org.slf4j:slf4j-api:1.7.25"\n    compile "ch.qos.logback:logback-classic:1.2.3"\n    compile "com.google.code.gson:gson:2.8.1"\n    compile "joda-time:joda-time:2.9.9"\n    compile "org.apache.httpcomponents:httpclient:4.5.6"\n    compile "org.apache.commons:commons-lang3:3.8.1"\n}'),a.Qb(),a.Ob(),a.Ob(),a.Pb(16,"h3"),a.zc(17,"Configuring Maven"),a.Ob(),a.Pb(18,"p"),a.zc(19," Next add a dependency to Transport\n"),a.Ob(),a.Pb(20,"pre",0),a.Pb(21,"code",2),a.Jb(),a.zc(22,"<dependencies>\n    <dependency>\n        <groupId>com.vmware.transport</groupId>\n        <artifactId>vmw-transport</artifactId>\n        <version>1.0.0</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n        <version>1.5.18.RELEASE</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-websocket</artifactId>\n        <version>1.5.18.RELEASE</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.security</groupId>\n        <artifactId>spring-security-web</artifactId>\n        <version>4.2.2.RELEASE</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.security</groupId>\n        <artifactId>spring-security-config</artifactId>\n        <version>4.2.2.RELEASE</version>\n    </dependency>\n    <dependency>\n        <groupId>io.reactivex.rxjava2</groupId>\n        <artifactId>rxjava</artifactId>\n        <version>2.1.9</version>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-databind</artifactId>\n        <version>2.9.4</version>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.module</groupId>\n        <artifactId>jackson-module-jsonSchema</artifactId>\n        <version>2.9.4</version>\n    </dependency>\n    <dependency>\n        <groupId>org.slf4j:slf4j</groupId>\n        <artifactId>slf4j-api</artifactId>\n        <version>1.7.25</version>\n    </dependency>\n    <dependency>\n        <groupId>ch.qos.logback</groupId>\n        <artifactId>logback-classic</artifactId>\n        <version>1.2.3</version>\n    </dependency>\n    <dependency>\n        <groupId>com.google.code.gson</groupId>\n        <artifactId>gson</artifactId>\n        <version>2.8.1</version>\n    </dependency>\n    <dependency>\n        <groupId>joda-time</groupId>\n        <artifactId>joda-time</artifactId>\n        <version>2.9.9</version>\n    </dependency>\n    <dependency>\n        <groupId>org.apache.httpcomponents</groupId>\n        <artifactId>httpclient</artifactId>\n        <version>4.5.6</version>\n    </dependency>\n    <dependency>\n        <groupId>org.apache.commons</groupId>\n        <artifactId>commons-lang3</artifactId>\n        <version>3.8.1</version>\n    </dependency>\n</dependencies>"),a.Qb(),a.Ob(),a.Ob(),a.Kb(23,"hr"),a.Pb(24,"a",3),a.zc(25,"Next Steps: Initializing Transport"),a.Ob())},directives:[s.b],styles:[""]}),e})(),O=(()=>{class e{constructor(){}ngOnInit(){}}return e.\u0275fac=function(n){return new(n||e)},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-initializing"]],decls:9,vars:0,consts:[[1,"emphasis"]],template:function(e,n){1&e&&(a.Pb(0,"h1"),a.zc(1,"Initializing Transport"),a.Ob(),a.Pb(2,"p"),a.zc(3," The Java version of Transport depends on Spring. This makes it much, much simpler to build your applications using the bus.\n"),a.Ob(),a.Pb(4,"p"),a.zc(5," There isn't actually anything you need to do to initialize the Transport. It's self booting once you import the Jar into your Java Application.\n"),a.Ob(),a.Pb(6,"p"),a.Pb(7,"strong",0),a.zc(8,"Pretty Cool eh? Don't you just \u2764\ufe0f Spring."),a.Ob(),a.Ob())},styles:[""]}),e})(),y=(()=>{class e{constructor(e){this.highlightService=e,this.highlighted=!1}ngOnInit(){}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(n){return new(n||e)(a.Ib(m.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-hello-world"]],decls:94,vars:0,consts:[[1,"code"],[1,"language-java"],[1,"log-output"],[1,"console-green"],[1,"console-pink"],[1,"console-blue"],[1,"console-grey"],[1,"clr-code"],[1,"emphasis"],["routerLink","/java/messaging",1,"btn","btn-primary","btn-block","btn-outline"]],template:function(e,n){1&e&&(a.Pb(0,"h1"),a.zc(1,"Hello World! (Java)"),a.Ob(),a.Pb(2,"p"),a.zc(3,"To demonstrate the simplest possible use of Transport, we will create a simple class that simply talks to its self."),a.Ob(),a.Pb(4,"h3"),a.zc(5,"Java HelloWorld"),a.Ob(),a.Pb(6,"pre",0),a.Pb(7,"code",1),a.Jb(),a.zc(8,'import com.vmware.transport.bus.model.Message;\nimport com.vmware.transport.core.AbstractBase;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class HelloWorld extends AbstractBase {\n\n    // define a channel.\n    private String myChannel;\n\n    // initialize is the only mandatory method required. This will always run on boot.\n    public void initialize() {\n\n        // create a local channel.\n        myChannel = "myChannel";\n\n        // create a responder\n        this.createResponder();\n        this.sendRequest();\n    }\n\n    // send a response to a request.\n    private void createResponder() {\n        this.bus.respondOnce(myChannel,\n                (Message msg) -> msg.getPayload().toString() + " world"\n        );\n    }\n\n    // send a request\n    private void sendRequest() {\n        this.bus.requestOnce(myChannel, "hello",\n                (Message msg) -> {\n                    this.logInfoMessage("HelloWorld:", "Got a response! ", msg.getPayload().toString());\n                }\n        );\n    }\n}'),a.Qb(),a.Ob(),a.Ob(),a.Pb(9,"p"),a.zc(10,"The output of the component is pretty basic. If you look at your console, you will see something like this"),a.Ob(),a.Pb(11,"pre",2),a.zc(12,"2021-03-20 22:19:37.229 "),a.Pb(13,"span",3),a.zc(14,"DEBUG"),a.Ob(),a.zc(15," "),a.Pb(16,"span",4),a.zc(17,"1526"),a.Ob(),a.zc(18," --- [main] "),a.Pb(19,"span",5),a.zc(20,"com.vmware.transport.bus.EventBusImpl"),a.Ob(),a.zc(21,"      : \ud83d\udd39  "),a.Pb(22,"span",6),a.zc(23,"Initializing Transport Service: HelloWorld"),a.Ob(),a.zc(24,"\n2021-03-20 22:19:37.248 "),a.Pb(25,"span",3),a.zc(26,"INFO"),a.Ob(),a.zc(27,"  "),a.Pb(28,"span",4),a.zc(29,"1526"),a.Ob(),a.zc(30," --- [main] "),a.Pb(31,"span",5),a.zc(32,"samples.HelloWorld"),a.Ob(),a.zc(33,"                         : "),a.Pb(34,"span",6),a.zc(35,"HelloWorld:  Got a response!:"),a.Ob(),a.zc(36," "),a.Pb(37,"strong",4),a.zc(38,"hello world"),a.Ob(),a.zc(39,"\n"),a.Ob(),a.Kb(40,"hr"),a.Pb(41,"h3"),a.zc(42,"Breakdown of what is happening"),a.Ob(),a.Pb(43,"p"),a.zc(44," The first requirement is to annotate your class with the "),a.Pb(45,"code",7),a.zc(46,"@Component"),a.Ob(),a.zc(47," annotation provided by Spring. This marks your class as a Spring Bean, meaning it will be picked up and loaded automatically.\n"),a.Ob(),a.Pb(48,"pre",0),a.Pb(49,"code",1),a.Jb(),a.zc(50,"@Component\npublic class HelloWorld extends AbstractBase {\n    // ...\n}\n"),a.Qb(),a.Ob(),a.Ob(),a.Pb(51,"p"),a.zc(52," The next step is to ensure your class extends from "),a.Pb(53,"code",7),a.zc(54,"AbstractBase"),a.Ob(),a.zc(55,". This is the same as the TypeScript version, however the Java version is mandatory, where the TypeScript version is optional.\n"),a.Ob(),a.Pb(56,"p"),a.zc(57," When you extend from "),a.Pb(58,"code",7),a.zc(59,"AbstractBase"),a.Ob(),a.zc(60,". You're also implementing the "),a.Pb(61,"code",7),a.zc(62,"TransportEnabled"),a.Ob(),a.zc(63," interface, which has a single method you need to implement. "),a.Pb(64,"code",7),a.zc(65,"initialize()"),a.Ob(),a.Ob(),a.Pb(66,"pre",0),a.Pb(67,"code",1),a.Jb(),a.zc(68,"@Component\npublic class HelloWorld extends AbstractBase {\n    public initialize() {\n        // ...\n    }\n}\n"),a.Qb(),a.Ob(),a.Ob(),a.Pb(69,"p"),a.Pb(70,"code",7),a.zc(71,"initialize()"),a.Ob(),a.zc(72," is your start point. You can use a Constructor, however you may not have access to the event bus at that point. It's "),a.Pb(73,"strong",8),a.zc(74,"Highly Recommended"),a.Ob(),a.zc(75," that you kick off anything you want to run from this method and "),a.Pb(76,"strong",8),a.zc(77,"Not the constructor."),a.Ob(),a.Ob(),a.Pb(78,"p"),a.zc(79," The rest of the example simply sets up a responder and sends a request on the "),a.Pb(80,"code",7),a.zc(81,"myChannel"),a.Ob(),a.zc(82," channel. The API is similar to the TypeScript API, with a few small differences. There is no "),a.Pb(83,"code",7),a.zc(84,"handle()"),a.Ob(),a.zc(85," method. You simply pass in your lambdas as and argument.\n"),a.Ob(),a.Kb(86,"hr"),a.Pb(87,"h3"),a.zc(88,"Why is the API slightly different to TypeScript?"),a.Ob(),a.Pb(89,"p"),a.zc(90," Java and TypeScript are completely different languages that operate in very different ways. TypeScript isn't executed, it's transpiled to JavaScript. All languages are different and bring their own designs, we have tried to keep the APIs as close as possible where it makes sense. We have used language specific techniques and designs in some places however.\n"),a.Ob(),a.Kb(91,"hr"),a.Pb(92,"a",9),a.zc(93,"Next Steps: Messaging Types"),a.Ob())},directives:[s.b],styles:[""]}),e})();const w=[{path:"",component:h,children:[{path:"",component:P},{path:"overview",component:P},{path:"importing",component:z},{path:"configuring",component:(()=>{class e{constructor(e){this.highlightService=e,this.highlighted=!1}ngOnInit(){}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(n){return new(n||e)(a.Ib(m.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-configuring"]],decls:121,vars:0,consts:[[1,"clr-code"],[1,"code"],[1,"language-java"],[1,"emphasis"],[1,"log-output"],[1,"console-green"],[1,"console-pink"],[1,"console-blue"],[1,"console-white"],[1,"console-grey"]],template:function(e,n){1&e&&(a.Pb(0,"h1"),a.zc(1," Configuring your Spring Application\n"),a.Ob(),a.Pb(2,"p"),a.zc(3," Transport makes use of Spring's magic under the covers, in a significant way. This has advantages and disadvantages. It's good because we don't have to re-invent the wheel. It's bad because it means the Java version of Transport is dependent on Spring to operate.\n"),a.Ob(),a.Kb(4,"hr"),a.Pb(5,"h3"),a.zc(6," The Transport Config Class.\n"),a.Ob(),a.Pb(7,"p"),a.zc(8," We use the "),a.Pb(9,"code",0),a.zc(10,"@Configuration"),a.Ob(),a.zc(11," annotation provided by Spring to set things up. We also then use the built in STOMP, Messaging, Broker and WebSocket support.\n"),a.Ob(),a.Pb(12,"p"),a.zc(13," When creating your configuration class, you need to implement the "),a.Pb(14,"code",0),a.zc(15,"TransportBridgeConfigurer"),a.Ob(),a.zc(16,". This interface allows you to define which endpoints your want your application to expose. This will default to '/fabric'.\n"),a.Ob(),a.Pb(17,"p"),a.zc(18," To enable Transport functionality for automatic local and remote broker integration, you need the "),a.Pb(19,"code",0),a.zc(20,"@EnableTransport"),a.Ob(),a.zc(21," annotation also. You can use the bus internally without this, but you won't get the benefits of connecting the bus to a broker.\n"),a.Ob(),a.Kb(22,"hr"),a.Pb(23,"h3"),a.zc(24," What is an endpoint?\n"),a.Ob(),a.Pb(25,"p"),a.zc(26," An endpoint is the destination you want to expose the STOMP pub-sub interface used by the TypeScript client, or any STOMP compatible client. The choice is up to you, however for consistency across applications, we recommend the default '/fabric' endpoint.\n"),a.Ob(),a.Kb(27,"hr"),a.Pb(28,"p"),a.zc(29," Inside your configuration, you can configure the endpoints, the allows origins (defaults to all), local broker (/topic) definitions and the publication prefix (/pub)\n"),a.Ob(),a.Pb(30,"p"),a.zc(31," The publication prefix is where messages are pushed into the local broker. You should not directly push to /topic, because you will receive an echo back yourself. The publication prefix ensures all subscribers get your message, but you don't get a copy back yourself if you're also subscribed to a destination.\n"),a.Ob(),a.Pb(32,"p"),a.zc(33," Here is an example of a Configuration that uses all the defaults. There isn't a need to change any of this, unless you have specific needs or conflicts.\n"),a.Ob(),a.Pb(34,"h3"),a.zc(35,"MyAppFabricConfiguration"),a.Ob(),a.Pb(36,"pre",1),a.Pb(37,"code",2),a.Jb(),a.zc(38,'package com.vmware.skyscraper.configs;\n\nimport com.vmware.transport.bridge.spring.config.TransportBridgeConfiguration;\nimport com.vmware.transport.bridge.spring.config.TransportBridgeConfigurer;\nimport com.vmware.transport.bridge.spring.config.annotation.EnableTransport;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.messaging.simp.config.MessageBrokerRegistry;\nimport org.springframework.web.socket.config.annotation.AbstractWebSocketMessageBrokerConfigurer;\nimport org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;\nimport org.springframework.web.socket.config.annotation.StompEndpointRegistry;\n\n/**\n * Transport Configuration.\n */\n@Configuration\n@EnableTransport\n@EnableWebSocketMessageBroker\npublic class MyConfiguration extends AbstractWebSocketMessageBrokerConfigurer\n        implements TransportBridgeConfigurer {\n\n    @Override\n    public void configureMessageBroker(MessageBrokerRegistry config) {\n        config.enableSimpleBroker("/topic");\n        config.setApplicationDestinationPrefixes("/pub");\n    }\n\n    @Override\n    public void registerStompEndpoints(StompEndpointRegistry registry) {\n        registry.addEndpoint("/fabric").setAllowedOrigins("*");\n    }\n\n    @Override\n    public void registerTransportDestinationPrefixes(TransportBridgeConfiguration configuration) {\n        configuration.addTransportDestinationPrefixes("/topic", "/pub");\n    }\n}\n'),a.Qb(),a.Ob(),a.Ob(),a.Pb(39,"h4",3),a.zc(40," And you're done!\n"),a.Ob(),a.Kb(41,"hr"),a.Pb(42,"h3"),a.zc(43," How do I know I am done?\n"),a.Ob(),a.Pb(44,"p"),a.zc(45,"When you boot you application, you will see something like the following in your console."),a.Ob(),a.Pb(46,"pre",4),a.zc(47,"2019-03-01 14:34:42.968  "),a.Pb(48,"span",5),a.zc(49,"INFO"),a.Ob(),a.zc(50,"  "),a.Pb(51,"span",6),a.zc(52,"50737"),a.Ob(),a.zc(53,"  --- [main] "),a.Pb(54,"span",7),a.zc(55,"o.s.w.s.s.s.WebSocketHandlerMapping"),a.Ob(),a.zc(56,"         : "),a.Pb(57,"span",8),a.zc(58,"Mapped URL path [/transport] onto handler of type [class org.springframework.web.socket.server.support.WebSocketHttpRequestHandler]"),a.Ob(),a.zc(59,"\n2021-03-20 14:34:42.969  "),a.Pb(60,"span",5),a.zc(61,"INFO"),a.Ob(),a.zc(62,"  "),a.Pb(63,"span",6),a.zc(64,"50737"),a.Ob(),a.zc(65,"  --- [main] "),a.Pb(66,"span",7),a.zc(67,"o.s.w.s.s.s.WebSocketHandlerMapping"),a.Ob(),a.zc(68,"         : "),a.Pb(69,"span",8),a.zc(70,"Mapped URL path [/fabric] onto handler of type [class org.springframework.web.socket.server.support.WebSocketHttpRequestHandler]"),a.Ob(),a.zc(71,"\n2021-03-20 14:34:43.154  "),a.Pb(72,"span",5),a.zc(73,"INFO"),a.Ob(),a.zc(74,"  "),a.Pb(75,"span",6),a.zc(76,"50737"),a.Ob(),a.zc(77,"  --- [main] "),a.Pb(78,"span",7),a.zc(79,".WebSocketAnnotationMethodMessageHandler"),a.Ob(),a.zc(80,"    : "),a.Pb(81,"span",8),a.zc(82,'Mapped "{[/{topicDestination}],messageType=[MESSAGE]}" onto public void com.vmware.transport.bridge.spring.controllers.MessageController.bridgeMessage(com.vmware.transport.bridge.Request,java.lang.String) throws com.vmware.transport.bridge.RequestException'),a.Ob(),a.zc(83,"\n2021-03-20 14:34:43.887  "),a.Pb(84,"span",5),a.zc(85,"INFO"),a.Ob(),a.zc(86,"  "),a.Pb(87,"span",6),a.zc(88,"50737"),a.Ob(),a.zc(89,"  --- [main] "),a.Pb(90,"span",7),a.zc(91,"com.vmware.transport.bus.EventBusImpl"),a.Ob(),a.zc(92,"       : \ud83c\udf08  "),a.Pb(93,"strong",6),a.zc(94,"Starting Transport"),a.Ob(),a.zc(95,"\n2021-03-20 14:34:43.912  "),a.Pb(96,"span",5),a.zc(97,"DEBUG"),a.Ob(),a.zc(98," "),a.Pb(99,"span",6),a.zc(100,"50737"),a.Ob(),a.zc(101,"  --- [main] "),a.Pb(102,"span",7),a.zc(103,"com.vmware.transport.bus.EventBusImpl"),a.Ob(),a.zc(104,"       : \ud83d\udd39  "),a.Pb(105,"span",9),a.zc(106,"Initializing Transport Service: RestService"),a.Ob(),a.zc(107,"\n2021-03-20 14:34:43.912  "),a.Pb(108,"span",5),a.zc(109,"INFO"),a.Ob(),a.zc(110,"  "),a.Pb(111,"span",6),a.zc(112,"50737"),a.Ob(),a.zc(113,"  --- [main] "),a.Pb(114,"span",7),a.zc(115,"c.v.transport.core.operations.RestService"),a.Ob(),a.zc(116,"   : \ud83d\udce3  "),a.Pb(117,"span",8),a.zc(118,"RestService initialized, handling requests on channel: "),a.Pb(119,"strong",6),a.zc(120,"transport-services::REST"),a.Ob(),a.Ob(),a.Ob())},styles:[""]}),e})()},{path:"initializing",component:O},{path:"hello-world",component:y},{path:"building-services",component:(()=>{class e{constructor(e){this.highlightService=e,this.highlighted=!1}ngOnInit(){}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(n){return new(n||e)(a.Ib(m.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-building-services"]],decls:36,vars:0,consts:[[1,"clr-code"],[1,"code"],[1,"language-java"],["routerLink","/java/private-channels",1,"btn","btn-primary","btn-block","btn-outline"]],template:function(e,n){1&e&&(a.Pb(0,"h1"),a.zc(1,"Building Services"),a.Ob(),a.Pb(2,"p"),a.zc(3," To get started, we should create a new class called "),a.Pb(4,"code",0),a.zc(5,"PongService"),a.Ob(),a.zc(6,".\n"),a.Ob(),a.Pb(7,"p"),a.zc(8," The first thing we need to do in order to create our first simple "),a.Pb(9,"code",0),a.zc(10,"PongService"),a.Ob(),a.zc(11," is create a "),a.Pb(12,"code",0),a.zc(13,"PongServiceRequest"),a.Ob(),a.zc(14," model and a "),a.Pb(15,"code",0),a.zc(16,"PongServiceResponse"),a.Ob(),a.zc(17," model. These two models are responsible for allowing other actors to know what to send to our service, and what to expect in response.\n"),a.Ob(),a.Pb(18,"h3"),a.zc(19,"Java PongService"),a.Ob(),a.Pb(20,"pre",1),a.Pb(21,"code",2),a.Jb(),a.zc(22,'\nimport com.vmware.transport.bridge.Request;\nimport com.vmware.transport.bridge.Response;\nimport com.vmware.transport.bus.Transaction;\nimport com.vmware.transport.bus.model.Message;\nimport com.vmware.transport.core.AbstractService;\nimport com.vmware.transport.core.util.ClassMapper;\nimport org.springframework.stereotype.Component;\nimport samples.CalendarService;\n\nimport java.util.UUID;\n\n@Component\npublic class PongService extends AbstractService<Request<String>, Response<String>> {\n    // define the channel the service operates on\n\n    public static final String Channel = "services-PongService";\n\n    PongService() {\n        super(PongService.Channel);\n    }\n\n    protected void handleServiceRequest(Request request, Message busMessage) {\n\n        // which command shall we run?\n        switch(request.getRequest()) {\n            case PongRequestType.Basic:\n                this.handleBasicPongRequest(request);\n                break;\n\n            case PongRequestType.Full:\n                this.handleFullPongRequest(request);\n                break;\n\n            case default:\n                this.handleUnknownRequest(request);\n                break;\n        }\n    }\n\n    /**\n     * Handle requests for basic pong needs\n     * @param request The request being sent over the bus.\n     */\n    private void handleBasicPongRequest(Request request) {\n\n        // prepare and send a basic response.\n        Response<String> response = new Response<>(request.getId(), "Fabric Pong (Basic): Pong");\n        this.sendResponse(response, request.getId(), request.getTargetUser());\n    }\n\n    /**\n     * Handle requests for full pong needs.\n     * @param request the request being sent over the bus.\n     */\n    private void handleFullPongRequest(Request request) {\n\n        UUID transactionId = request.getId();\n\n        // call our calendar service and get a date and time, in two separate synchronous calls via transaction, pass\n        // in our request ID as the transaction ID, so it can be tracked correctly across service calls.\n        Transaction transaction = bus.createTransaction(Transaction.TransactionType.SYNC, "calendar-transaction", transactionId);\n\n        // queue up requests for time and date via Calendar Service.\n        transaction.sendRequest(CalendarService.Channel, new Request<String>(transactionId, "date")); // request date\n        transaction.sendRequest(CalendarService.Channel, new Request<String>(transactionId, "time")); // request time\n\n        // register complete handler for transaction.\n        transaction.onComplete(\n                (Message[] responses) -> {\n\n                    // concatenate service responses into a string.\n                    StringBuilder dateAndTime = new StringBuilder();\n                    for(Message msg: responses) {\n                        String calendarResponse = ClassMapper.CastPayload(String.class, (Response)msg.getPayload());\n                        dateAndTime.append(calendarResponse + " "); // add each response together.\n                    }\n\n                    // prepare a response, with our date and time requests stuck together as a more elaborate response.\n                    Response<String> response = new Response<>(request.getId(),\n                            "Fabric Pong (Full): Pong++ " + dateAndTime.toString());\n                    this.sendResponse(response, request.getId(), request.getTargetUser());\n                }\n        );\n\n        // commit transaction.\n        transaction.commit();\n    }\n}\n\nabstract class PongRequestType {\n    static final String Basic = "Basic";\n    static final String Full = "Full";\n}\n'),a.Qb(),a.Ob(),a.Ob(),a.Pb(23,"h3"),a.zc(24," What is happening in the sample?\n"),a.Ob(),a.Pb(25,"p"),a.zc(26," First of all, the "),a.Pb(27,"code",0),a.zc(28,"PongService"),a.Ob(),a.zc(29," is handling two requests 'Basic' and 'Full' and everything else is returned as an error, with an unknown request.\n"),a.Ob(),a.Pb(30,"pre",1),a.Pb(31,"code",2),a.Jb(),a.zc(32,"...\nprotected void handleServiceRequest(Request request, Message busMessage) {\n\n    // which command shall we run?\n    switch(request.getRequest()) {\n        case PongRequestType.Basic:\n            this.handleBasicPongRequest(request);\n            break;\n\n        case PongRequestType.Full:\n            this.handleFullPongRequest(request);\n            break;\n\n        case default:\n            this.handleUnknownRequest(request);\n            break;\n    }\n}\n..."),a.Qb(),a.Ob(),a.Ob(),a.Kb(33,"hr"),a.Pb(34,"a",3),a.zc(35,"Next Steps: Private Channels"),a.Ob())},directives:[s.b],styles:[""]}),e})()},{path:"messaging",component:(()=>{class e{constructor(e){this.highlightService=e,this.highlighted=!1}ngOnInit(){}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(n){return new(n||e)(a.Ib(m.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-messaging"]],decls:65,vars:0,consts:[[1,"clr-code"],[1,"empahsis"],[1,"code"],[1,"language-typescript"],["routerLink","/java/building-services",1,"btn","btn-primary","btn-block","btn-outline"]],template:function(e,n){1&e&&(a.Pb(0,"h1"),a.zc(1,"Understanding 'broadcast' vs 'direct' messaging"),a.Ob(),a.Pb(2,"p"),a.zc(3," Transport is analogous to Slack (for software), except Transport allows direct messages inside a channel, where as Slack opens up stand-alone conversations between actors outside of a channel. The concept however remains the same. When a component needs to restrict a conversation between its self, and a service - we can use a direct message.\n"),a.Ob(),a.Pb(4,"p"),a.zc(5," When another Class/Service is interested in everything being broadcast by a service, then that actor can simply subscribe to the service channel and listen for everything.\n"),a.Ob(),a.Pb(6,"p"),a.zc(7," The use case for direct messaging between a consumer and service arrives when you need a specific response to be delivered to a specific consumer, i.e. you don't want every other listener on that channel getting that same response (because we're operating on a single channel). It's like talking in a public chat, vs talking in a direct message with that service.\n"),a.Ob(),a.Kb(8,"hr"),a.Pb(9,"h3"),a.zc(10,"Sending requests using ID's"),a.Ob(),a.Pb(11,"p"),a.zc(12," There are three ways to conduct direct messaging. The first is to use methods in the API that accept an ID. Every API (like request once "),a.Pb(13,"code",0),a.zc(14,"()"),a.Ob(),a.zc(15,") has two variations, the first is the same method name that has "),a.Pb(16,"code",0),a.zc(17,"...withId()"),a.Ob(),a.zc(18," appended to the end of the name.\n"),a.Ob(),a.Pb(19,"p"),a.zc(20," The second is "),a.Pb(21,"code",0),a.zc(22,"...withIdAndVersion()"),a.Ob(),a.zc(23,". The signature for both is mostly the same, except they obviously take an ID, or an ID and a version. Versions are not used yet, however support is coming in future versions of the fabric.\n"),a.Ob(),a.Pb(24,"p"),a.zc(25," The third is with a "),a.Pb(26,"strong",1),a.zc(27,"Transaction"),a.Ob(),a.zc(28,".\n"),a.Ob(),a.Pb(29,"p"),a.zc(30," Let's take a look at an example of using one of these methods:\n"),a.Ob(),a.Pb(31,"pre",2),a.Pb(32,"code",3),a.Jb(),a.zc(33,"const request: PongServiceRequest = {\n    command: PongRequestType.Basic,\n    message: 'basic ping'\n};\n\nthis.bus.requestOnceWithId<PongServiceRequest, PongServiceResponse>(\n    UUID.randomUUID();,           // message id\n    'my-channel',                 // channel on which to send request\n    request,                      // payload to be sent on the channe\n).handle(\n    (response: SomeTypedResponse) => {\n        // do something with this successful request\n    },\n    (error: GeneralError) => {\n        // something went wrong, lets handle it.\n    }\n);"),a.Qb(),a.Ob(),a.Ob(),a.Pb(34,"p"),a.zc(35," The above example will send a request to "),a.Pb(36,"code",0),a.zc(37,"PongService"),a.Ob(),a.zc(38,", but this time, we're sending that message with a "),a.Pb(39,"strong"),a.zc(40,"Random UUID"),a.Ob(),a.zc(41,". This means that the consumer is only going to listen for a response that "),a.Pb(42,"strong"),a.zc(43,"also contains that same ID"),a.Ob(),a.zc(44,". Any other response coming in over "),a.Pb(45,"code",0),a.zc(46,"PongServiceChannel"),a.Ob(),a.zc(47," that has a different ID, or has no ID "),a.Pb(48,"strong"),a.zc(49,"will be ignored"),a.Ob(),a.zc(50," by the "),a.Pb(51,"code",0),a.zc(52,"handle(...)"),a.Ob(),a.zc(53," method.\n"),a.Ob(),a.Kb(54,"hr"),a.Pb(55,"h3"),a.zc(56,"Quick note on generating UUID's"),a.Ob(),a.Pb(57,"p"),a.zc(58," Always use a valid UUID. Java makes it really easy. "),a.Pb(59,"code",0),a.zc(60,"UUID.randomUUID()"),a.Ob(),a.zc(61," is all you need.\n"),a.Ob(),a.Kb(62,"hr"),a.Pb(63,"a",4),a.zc(64,"Next Steps: Building Services"),a.Ob())},directives:[s.b],styles:[""]}),e})()},{path:"private-channels",component:(()=>{class e{constructor(e){this.highlightService=e,this.highlighted=!1}ngOnInit(){}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(n){return new(n||e)(a.Ib(m.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-private-channels"]],decls:77,vars:0,consts:[["routerLink","/java/messaging"],["routerLink","/java/configuring"],[1,"clr-code"],[1,"code"],[1,"language-java"],["routerLink","/java/building-services"],["routerLink","/ts/extending-channels"],[1,"language-ts"],["routerLink","/java/transactions",1,"btn","btn-primary","btn-block","btn-outline"]],template:function(e,n){1&e&&(a.Pb(0,"h1"),a.zc(1,"Using Private Channels"),a.Ob(),a.Pb(2,"p"),a.zc(3," The three ways to conduct direct messaging, as discussed in "),a.Pb(4,"a",0),a.zc(5,"Messaging Types"),a.Ob(),a.zc(6,", have one caveat; it uses a single WebSocket endpoint for both broadcast and direct messaging. The filtering mechanism is implemented on the client side. What this implies is that while the UI will not be able to see and process the response meant for another client's request with a different request ID, under the hood you can still see the message packet arriving at your browser using inspection tools. This could pose a security problem and might not be a feasible solution.\n"),a.Ob(),a.Pb(7,"p"),a.zc(8," With Transport, you can now set up 1:1 private channels between the broker and clients which ensures all communication between a client and the broker will always happen on a dedicated channel and other clients will not be able to see the message at all.\n"),a.Ob(),a.Pb(9,"p"),a.zc(10," See the following steps to configure and send to and receive from a private channel.\n"),a.Ob(),a.Kb(11,"hr"),a.Pb(12,"h3"),a.zc(13," Configure Spring Boot to add a broker endpoint for private channels\n"),a.Ob(),a.Pb(14,"p"),a.zc(15," Take MyConfiguration from "),a.Pb(16,"a",1),a.zc(17,"Configuring Spring"),a.Ob(),a.zc(18," as the starting point. Here we want to 1) add a new endpoint "),a.Pb(19,"code",2),a.zc(20,"/queue"),a.Ob(),a.zc(21," as the main endpoint for private conversations, and 2) configure a default handshake handler for the STOMP session. The handshake handler is responsible for generating and assigning a unique ID to each session.\n"),a.Ob(),a.Pb(22,"h3"),a.zc(23,"MyConfiguration"),a.Ob(),a.Pb(24,"pre",3),a.Pb(25,"code",4),a.Jb(),a.zc(26,'// ...\n    @Override\n    public void configureMessageBroker(MessageBrokerRegistry config) {\n        config.enableSimpleBroker("/topic", "/queue", "/pub");\n        config.setApplicationDestinationPrefixes("/pub");\n    }\n\n    @Override\n    public void registerStompEndpoints(StompEndpointRegistry registry) {\n        registry.addEndpoint("/fabric")\n                .setAllowedOrigins("*")\n                .setHandshakeHandler(new DefaultHandshakeHandler() {\n                    @Override\n                    protected Principal determineUser(ServerHttpRequest request,\n                                                      WebSocketHandler wsHandler,\n                                                      Map<String, Object>> attributes) {\n                        return new SessionPrincipal(UUID.randomUUID().toString());\n                    }\n                });\n    }\n\n    @Override\n    public void registerTransportDestinationPrefixes(TransportBridgeConfiguration configuration) {\n        configuration.addTransportDestinationPrefixes("/topic", "/pub", "/user/queue");\n    }\n// ...\n'),a.Qb(),a.Ob(),a.Ob(),a.Pb(27,"h3"),a.zc(28,"Principal implementation example"),a.Ob(),a.Pb(29,"pre",3),a.Pb(30,"code",4),a.Jb(),a.zc(31,"public class SessionPrincipal implements Principal {\n    private String name;\n\n    public SessionPrincipal(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n"),a.Qb(),a.Ob(),a.Ob(),a.Kb(32,"hr"),a.Pb(33,"h3"),a.zc(34," Then modify your service's "),a.Pb(35,"code",2),a.zc(36,"sendResponse()"),a.Ob(),a.zc(37," and "),a.Pb(38,"code",2),a.zc(39,"sendError()"),a.Ob(),a.Ob(),a.Pb(40,"p"),a.zc(41," See how "),a.Pb(42,"code",2),a.zc(43,"sendResponse()"),a.Ob(),a.zc(44," in "),a.Pb(45,"code",2),a.zc(46,"PongService"),a.Ob(),a.zc(47," of the "),a.Pb(48,"a",5),a.zc(49,"Building Services"),a.Ob(),a.zc(50," section accepts three arguments. The last argument describes the destination's session identifier so that the message or error message, in the case of "),a.Pb(51,"code",2),a.zc(52,"sendError()"),a.Ob(),a.zc(53,", will reach its intended audience.\n"),a.Ob(),a.Kb(54,"hr"),a.Pb(55,"h3"),a.zc(56," And finally, mark the channel as private from the UI\n"),a.Ob(),a.Pb(57,"p"),a.Pb(58,"code",2),a.zc(59,"markChannelAsGalactic()"),a.Ob(),a.zc(60," method accepts a channel name as the first required argument, and whether it's a private channel as the second, optional boolean value. By default it is set to false, meaning if you marked your channel without explicitly specifying that it should be a private channel, it would be a broadcast channel. See "),a.Pb(61,"a",6),a.zc(62,"Extending channels"),a.Ob(),a.zc(63," as a reference. If you wanted to turn the servbot channel private, you would need to simply turn the following:\n"),a.Ob(),a.Pb(64,"pre",3),a.Pb(65,"code",7),a.Jb(),a.zc(66,"this.bus.markChannelAsGalactic('sergeant-fox');"),a.Qb(),a.Ob(),a.Ob(),a.Pb(67,"p"),a.zc(68," into this:\n"),a.Ob(),a.Pb(69,"pre",3),a.Pb(70,"code",7),a.Jb(),a.zc(71,"this.bus.markChannelAsGalactic('sergeant-fox', true);"),a.Qb(),a.Ob(),a.Ob(),a.Pb(72,"p"),a.zc(73," Try out the sample in multiple browser tabs and notice using your browser's inspect tools how each response is delivered only to the client that made the request.\n"),a.Ob(),a.Kb(74,"hr"),a.Pb(75,"a",8),a.zc(76,"Next Steps: Transactions"),a.Ob())},directives:[s.b],styles:[""]}),e})()},{path:"transactions",component:(()=>{class e{constructor(e){this.highlightService=e,this.highlighted=!1}ngOnInit(){}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(n){return new(n||e)(a.Ib(m.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-transactions"]],decls:129,vars:0,consts:[[1,"clr-code"],[1,"list"],[1,"emphasis"],[1,"code"],[1,"language-typescript"],["routerLink","/java/logging",1,"btn","btn-primary","btn-block","btn-outline"]],template:function(e,n){1&e&&(a.Pb(0,"h1"),a.zc(1,"Using Transactions."),a.Ob(),a.Pb(2,"p"),a.zc(3," A technique that can be used to encapsulate a conversation between a component and a service, or between services themselves - is to use a transaction.\n"),a.Ob(),a.Pb(4,"p"),a.zc(5," Transactions via Transport are not traditional transactions, in the sense that they can be rolled back if they fail, instead they are defined as a group of requests and responses that have to occur before the transaction can be considered complete.\n"),a.Ob(),a.Pb(6,"p"),a.zc(7," For example, if you need to call a number of services to get a number of responses, in order to be able to construct a response for a component - this would be a transactions. "),a.Ob(),a.Pb(8,"p"),a.zc(9," Similarly if you need to make a number of calls to services and wait for stores to be available and populated, this would also be a transaction. Transactions can be either synchronous, or asynchronous.\n"),a.Ob(),a.Pb(10,"p"),a.zc(11," Transactions are asynchronous by default. Essentially when you commit transactions, all the requests will be fired at once, the transaction will complete once responses to all those requests have been completed. These responses can arrive in any order and at any time (hence the asynchronous nature).\n"),a.Ob(),a.Pb(12,"p"),a.zc(13," However there may be times when you want your logic to run in a synchronous manner (due to your API design for example). When running a synchronous transaction, each request in the transaction will only fire once the previous one has completed. This is obviously a lot slower, but may be required based on your needs.\n"),a.Ob(),a.Kb(14,"hr"),a.Pb(15,"h3"),a.zc(16," How do I create / start a transaction?\n"),a.Ob(),a.Pb(17,"p"),a.Pb(18,"code",0),a.zc(19,"this.bus.createTransaction()"),a.Ob(),a.zc(20," is the simplest way to create any transaction. You will be returned a "),a.Pb(21,"code",0),a.zc(22,"Transaction"),a.Ob(),a.zc(23," object, which allows you to track progress of the transaction and more.\n"),a.Ob(),a.Pb(24,"h3"),a.zc(25," What types of transactions are there available?\n"),a.Ob(),a.Pb(26,"p"),a.zc(27," There are two types of transactions available.\n"),a.Ob(),a.Pb(28,"ol",1),a.Pb(29,"li"),a.Pb(30,"code",0),a.zc(31,"Asynchronous"),a.Ob(),a.zc(32," - "),a.Pb(33,"span",2),a.zc(34,"All requests fired at once, no way to determine which response comes back in which order."),a.Ob(),a.Ob(),a.Pb(35,"li"),a.Pb(36,"code",0),a.zc(37,"Synchronous"),a.Ob(),a.zc(38," - "),a.Pb(39,"span",2),a.zc(40,"Each request is fired only after the previous request has returned."),a.Ob(),a.Ob(),a.Ob(),a.Pb(41,"p"),a.zc(42," If don't care about which order your responses come back in, then "),a.Pb(43,"code",0),a.zc(44,"Asynchronous"),a.Ob(),a.zc(45," is what you're looking for. If you need all your responses to be returned in sequence, ensuring a stepped one-at-a-time process, then "),a.Pb(46,"code",0),a.zc(47,"Synchronous"),a.Ob(),a.zc(48," is what you need. "),a.Pb(49,"code",0),a.zc(50,"Asynchronous"),a.Ob(),a.zc(51," transactions are "),a.Pb(52,"strong",2),a.zc(53,"MUCH FASTER"),a.Ob(),a.Ob(),a.Pb(54,"h3"),a.zc(55," What happens if something goes wrong mid-transaction?\n"),a.Ob(),a.Pb(56,"p"),a.zc(57," Like with every other fabric concept, we have built success and error handlers for every operation. If a service errors out during the transaction, then the error handler you supply via "),a.Pb(58,"code",0),a.zc(59,"transaction.onError()"),a.Ob(),a.zc(60," will be triggered. You will receive the error that occurred. The remainder of the transaction will be stopped.\n"),a.Ob(),a.Kb(61,"hr"),a.Pb(62,"p"),a.zc(63," Below is an example of a Java Consumer that calls "),a.Pb(64,"code",0),a.zc(65,"PongService"),a.Ob(),a.zc(66," and "),a.Pb(67,"code",0),a.zc(68,"CalendarService"),a.Ob(),a.zc(69," via an asynchronous transaction\n"),a.Ob(),a.Pb(70,"h3"),a.zc(71,"Java PongCalendarServiceConsumer"),a.Ob(),a.Pb(72,"pre",3),a.Pb(73,"code",4),a.Jb(),a.zc(74,'package samples.pong;\n\nimport com.vmware.transport.bridge.Request;\nimport com.vmware.transport.bridge.Response;\nimport com.vmware.transport.bus.Transaction;\nimport com.vmware.transport.bus.model.Message;\nimport com.vmware.transport.core.AbstractBase;\nimport com.vmware.transport.core.util.ClassMapper;\nimport org.springframework.stereotype.Component;\nimport samples.calendar.CalendarService;\n\nimport java.util.UUID;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\n@Component\npublic class PongCalendarServiceConsumer extends AbstractBase {\n\n    private ScheduledExecutorService executorService;\n\n    PongCalendarServiceConsumer() { this.executorService = Executors.newScheduledThreadPool(5); }\n\n    /**\n     * Call PongService and Calendar Service as a part of a transaction\n     */\n    @Override\n    public void initialize() {\n        // create task, wait 1 second before executing.\n        Runnable runTransactionTask = () -> this.runTransaction();\n        executorService.schedule(runTransactionTask, 1000,  TimeUnit.MILLISECONDS);\n    }\n\n    private void runTransaction() {\n        // create async transaction\n        UUID transactionId = UUID.randomUUID();\n        Transaction transaction = bus.createTransaction(Transaction.TransactionType.ASYNC, transactionId);\n\n        // send request to PongService\n        transaction.sendRequest(\n                PongService.Channel,\n                new Request<String>(transactionId, "Basic") // request basic pong\n        );\n\n        // send request to CalendarService\n        transaction.sendRequest(\n                CalendarService.Channel,\n                new Request<String>(transactionId, "time") // request time\n        );\n\n        // when transaction is done\n        transaction.onComplete(\n                (Message[] responses) -> {\n\n                    // concatenate service responses into a string.\n                    StringBuilder serviceResponses = new StringBuilder();\n                    for(Message msg: responses) {\n\n                        String serviceResponse = ClassMapper.CastPayload(String.class, (Response)msg.getPayload());\n                        serviceResponses.append("> " + serviceResponse + " "); // add each response together.\n                    }\n\n                    // log output.\n                    this.logInfoMessage("PongCalendarServiceConsumer:", "Response", serviceResponses.toString());\n                }\n        );\n\n        // commit transaction.\n        transaction.commit();\n    }\n}'),a.Qb(),a.Ob(),a.Ob(),a.Kb(75,"hr"),a.Pb(76,"h3"),a.zc(77," What is happening in this example?\n"),a.Ob(),a.Pb(78,"pre",3),a.Pb(79,"code",4),a.Jb(),a.zc(80,"...\n@Component\npublic class PongCalendarServiceConsumer extends AbstractBase {\n\n    private ScheduledExecutorService executorService;\n\n    PongCalendarServiceConsumer() { this.executorService = Executors.newScheduledThreadPool(5); }\n\n    /**\n     * Call PongService and Calendar Service as a part of a transaction\n     */\n    @Override\n    public void initialize() {\n        // create task, wait 1 second before executing.\n        Runnable runTransactionTask = () -> this.runTransaction();\n        executorService.schedule(runTransactionTask, 1000,  TimeUnit.MILLISECONDS);\n    }\n\n..."),a.Qb(),a.Ob(),a.Ob(),a.Pb(81,"p"),a.zc(82,"The first thing this example does is create a new scheduled Java Executor, this is so we can push a Runnable lambda that performs a unit of work, after a certain delay. We do this because this is a working demo, we have to ensure every other service is up before we can start calling them."),a.Ob(),a.Pb(83,"p"),a.zc(84," One thing we're also doing here is ensuring that all service requests in a transaction, use the same ID for each message going across each channel. You can see this in action when we create a "),a.Pb(85,"code",0),a.zc(86,"UUID"),a.Ob(),a.zc(87," that is fed into the transaction, and each request going out.\n"),a.Ob(),a.Pb(88,"pre",3),a.Pb(89,"code",4),a.Jb(),a.zc(90,"...\nprivate void runTransaction() {\n    // create async transaction\n    UUID transactionId = UUID.randomUUID();\n    Transaction transaction = bus.createTransaction(Transaction.TransactionType.ASYNC, transactionId);\n..."),a.Qb(),a.Ob(),a.Ob(),a.Pb(91,"p"),a.zc(92," In this next step, we created a new "),a.Pb(93,"code",0),a.zc(94,"Transaction"),a.Ob(),a.zc(95," that is "),a.Pb(96,"code",0),a.zc(97,"ASYNC"),a.Ob(),a.zc(98,". This means our transaction will fire every request at the same time and collect responses in any order they arrive.\n"),a.Ob(),a.Pb(99,"pre",3),a.Pb(100,"code",4),a.Jb(),a.zc(101,'...\n// send request to PongService\ntransaction.sendRequest(\n    PongService.Channel,\n    new Request<String>(transactionId, "Basic") // request basic pong\n);\n\n// send request to CalendarService\ntransaction.sendRequest(\n        CalendarService.Channel,\n        new Request<String>(transactionId, "time") // request time\n);\n...'),a.Qb(),a.Ob(),a.Ob(),a.Pb(102,"p"),a.zc(103," In the above step, we actually queue up requests to be sent out as a part of the transaction. In this case, there are two requests, once is for t the "),a.Pb(104,"code",0),a.zc(105,"CalendarService"),a.Ob(),a.zc(106," and the other is for the "),a.Pb(107,"code",0),a.zc(108,"PongService"),a.Ob(),a.Ob(),a.zc(109,". "),a.Pb(110,"pre",3),a.Pb(111,"code",4),a.Jb(),a.zc(112,'...\n// when transaction is done\ntransaction.onComplete(\n    (Message[] responses) -> {\n\n        // concatenate service responses into a string.\n        StringBuilder serviceResponses = new StringBuilder();\n        for(Message msg: responses) {\n\n            String serviceResponse = ClassMapper.CastPayload(String.class, (Response)msg.getPayload());\n            serviceResponses.append("> " + serviceResponse + " "); // add each response together.\n        }\n\n        // log output.\n        this.logInfoMessage("PongCalendarServiceConsumer:", "Response", serviceResponses.toString());\n    }\n);\n...'),a.Qb(),a.Ob(),a.Ob(),a.Pb(113,"p"),a.zc(114," In the above sample, we're defining our success handler for a successfully completed transaction. Your success handler will simply be passed an array of "),a.Pb(115,"code",0),a.zc(116,"Message"),a.Ob(),a.zc(117," objects. YOu can then do what you need to with these objects, they will be in a random order if the transaction is async, otherwise they will be in the same order your requests were queued up in.\n"),a.Ob(),a.Pb(118,"pre",3),a.Pb(119,"code",4),a.Jb(),a.zc(120,"...\n // commit transaction.\ntransaction.commit();\n..."),a.Qb(),a.Ob(),a.Ob(),a.Pb(121,"p"),a.zc(122," The last step is to commit the transaction, this essentially fires everything off. Nothing happens until you commit the transaction. The "),a.Pb(123,"code",0),a.zc(124,"commit()"),a.Ob(),a.zc(125," method returns immediately and the transaction begins.\n"),a.Ob(),a.Kb(126,"hr"),a.Pb(127,"a",5),a.zc(128,"Next Steps: Logging"),a.Ob())},directives:[s.b],styles:[""]}),e})()},{path:"logging",component:(()=>{class e{constructor(){}ngOnInit(){}}return e.\u0275fac=function(n){return new(n||e)},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-logging"]],decls:77,vars:0,consts:[[1,"clr-code"],[1,"list"],[1,"emphasis"],["routerLink","/java/rest",1,"btn","btn-primary","btn-block","btn-outline"]],template:function(e,n){1&e&&(a.Pb(0,"h1"),a.zc(1,"Logging (Java)"),a.Ob(),a.Pb(2,"h3"),a.zc(3," >> Please don't use "),a.Pb(4,"code",0),a.zc(5,"System.out.println()"),a.Ob(),a.zc(6," <<\n"),a.Ob(),a.Pb(7,"p"),a.zc(8," When using any of the abstractions provided, they all extend from a single base class called "),a.Pb(9,"code",0),a.zc(10,"Loggable"),a.Ob(),a.zc(11,".\n"),a.Ob(),a.Pb(12,"p"),a.zc(13," We have created simple helper methods, that provide consistent console output for all levels of logging, however you also have access to "),a.Pb(14,"code",0),a.zc(15,"log"),a.Ob(),a.zc(16," Which allows you to control your own logging if you don't want to use the pre-defined logging methods available.\n"),a.Ob(),a.Pb(17,"p"),a.zc(18," There are a number of logging methods, for each standardized level\n"),a.Ob(),a.Kb(19,"hr"),a.Pb(20,"ol",1),a.Pb(21,"li"),a.Pb(22,"code",0),a.zc(23,"logInfoMessage(String emoji, String message, String value)"),a.Ob(),a.zc(24," - "),a.Pb(25,"span",2),a.zc(26," INFO level message"),a.Ob(),a.Ob(),a.Pb(27,"li"),a.Pb(28,"code",0),a.zc(29,"logErrorMessage(String message, String value)"),a.Ob(),a.zc(30," - "),a.Pb(31,"span",2),a.zc(32,"ERROR level message."),a.Ob(),a.Ob(),a.Pb(33,"li"),a.Pb(34,"code",0),a.zc(35,"logDebugMessage(String message, String value)"),a.Ob(),a.zc(36," - "),a.Pb(37,"span",2),a.zc(38,"DEBUG level message."),a.Ob(),a.Ob(),a.Pb(39,"li"),a.Pb(40,"code",0),a.zc(41,"logDebugMessage(String message)"),a.Ob(),a.zc(42," - "),a.Pb(43,"span",2),a.zc(44,"DEBUG level message."),a.Ob(),a.Ob(),a.Pb(45,"li"),a.Pb(46,"code",0),a.zc(47,"logTraceMessage(String message, String value)"),a.Ob(),a.zc(48," - "),a.Pb(49,"span",2),a.zc(50,"TRACE level message."),a.Ob(),a.Ob(),a.Pb(51,"li"),a.Pb(52,"code",0),a.zc(53,"logWarnMessage(String message)"),a.Ob(),a.zc(54," - "),a.Pb(55,"span",2),a.zc(56,"WARN level message."),a.Ob(),a.Ob(),a.Ob(),a.Kb(57,"hr"),a.Pb(58,"h3"),a.zc(59,"Using standard logging"),a.Ob(),a.Pb(60,"p"),a.zc(61," If you don't want to use the methods supplied, for what ever reason - you can access "),a.Pb(62,"code",0),a.zc(63,"this.log"),a.Ob(),a.zc(64," when using "),a.Pb(65,"code",0),a.zc(66,"AbstractBase"),a.Ob(),a.zc(67," as your superclass. When using "),a.Pb(68,"code",0),a.zc(69,"this.log"),a.Ob(),a.zc(70,", you actually have a reference to "),a.Pb(71,"code",0),a.zc(72,"org.slf4j.Logger"),a.Ob(),a.zc(73,".\n"),a.Ob(),a.Kb(74,"hr"),a.Pb(75,"a",3),a.zc(76,"Next Steps: Calling RESTFUL APIs"),a.Ob())},directives:[s.b],styles:[""]}),e})()},{path:"rest",component:(()=>{class e{constructor(e){this.highlightService=e,this.highlighted=!1}ngOnInit(){}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(n){return new(n||e)(a.Ib(m.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-rest"]],decls:96,vars:0,consts:[[1,"clr-code"],[1,"emphasis"],[1,"code"],[1,"language-java"],["routerLink","/java/abstractions",1,"btn","btn-primary","btn-block","btn-outline"]],template:function(e,n){1&e&&(a.Pb(0,"h1"),a.zc(1,"Making RESTful API Requests"),a.Ob(),a.Pb(2,"p"),a.zc(3," At some point (pretty quickly) you will need to start making remote calls to APIs in order to do interesting things.\n"),a.Ob(),a.Pb(4,"p"),a.zc(5," Transport provides a built-in service that abstracts the need to be concerned with handling HTTP operations. The Java version of the RestService is a little more advanced than the TypeScript version.\n"),a.Ob(),a.Pb(6,"p"),a.zc(7," The Java version of "),a.Pb(8,"code",0),a.zc(9,"RestService"),a.Ob(),a.zc(10," knows how to make remote calls to external URIs, as well as knowing how to make calls to local Rest Controllers in your existing application. If the URI is local to your Java application, the RestService will "),a.Pb(11,"strong"),a.zc(12,"Look up your Rest Controller using reflection"),a.Ob(),a.zc(13," and ensure it's a match. Once the local controller has been found, the RestService will "),a.Pb(14,"strong",1),a.zc(15,"call your controller locally"),a.Ob(),a.zc(16,". This means all existing security is also honoured and evaluated, there is also no additional network hop.\n"),a.Ob(),a.Pb(17,"p"),a.zc(18," The "),a.Pb(19,"code",0),a.zc(20,"RestService"),a.Ob(),a.zc(21," provides operations for "),a.Pb(22,"code",0),a.zc(23,"GET, PUT, POST, PATCH"),a.Ob(),a.zc(24," and "),a.Pb(25,"code",0),a.zc(26,"DELETE"),a.Ob(),a.zc(27," RESTful RPC calls. It can be called from your service when you extend from "),a.Pb(28,"code",0),a.zc(29,"AbstractService"),a.Ob(),a.zc(30,". It can also be called from your class when you extend from "),a.Pb(31,"code",0),a.zc(32,"AbstractBase"),a.Ob(),a.zc(33,".\n"),a.Ob(),a.Kb(34,"hr"),a.Pb(35,"h3"),a.zc(36,"Loading the RestService"),a.Ob(),a.Pb(37,"p"),a.zc(38," The RestService is automatically loaded when Transport boots. There is no need to instantiate it manually\n"),a.Ob(),a.Pb(39,"p"),a.zc(40," In Angular applications, this would be in your "),a.Pb(41,"code",0),a.zc(42,"main.ts"),a.Ob(),a.zc(43," file. Like with Services you build yourself, you would use the "),a.Pb(44,"code",0),a.zc(45,"ServiceLoader"),a.Ob(),a.zc(46," to instantiate and boot the "),a.Pb(47,"code",0),a.zc(48,"RestService"),a.Ob(),a.zc(49," and start it listening for requests.\n"),a.Ob(),a.Pb(50,"h3"),a.zc(51,"Calling RestService from a Java Class"),a.Ob(),a.Pb(52,"p"),a.zc(53," When your service extends from "),a.Pb(54,"code",0),a.zc(55,"AbstractBase"),a.Ob(),a.zc(56," or "),a.Pb(57,"code",0),a.zc(58,"AbstractService"),a.Ob(),a.zc(59,", a method named "),a.Pb(60,"code",0),a.zc(61,"restServiceRequest()"),a.Ob(),a.zc(62," is provided. There are a couple of overloaded versions of the method, however we will focus on the main one.\n"),a.Ob(),a.Pb(63,"pre",2),a.Pb(64,"code",3),a.Jb(),a.zc(65,"/**\n * Used By RestService to convert an incoming request into a RestOperation.\n * @param <Payld> The Request Payload Type (what is being sent)\n * @param <Resp> The Response Payload Type (what we're expecting back)\n */\npublic class RestOperation<Payld, Resp> {\n    @Getter @Setter\n    private UUID id;\n\n    @Getter @Setter\n    private URI uri;\n\n    @Getter @Setter\n    private HttpMethod method;\n\n    @Getter @Setter\n    private Payld body;\n\n    @Getter @Setter\n    private String apiClass;\n\n    @Getter @Setter\n    private Map<String,String> headers;\n\n    @Getter @Setter\n    private String sentFrom;\n\n    @Getter @Setter\n    private Consumer<Resp> successHandler;\n\n    @Getter @Setter\n    private Consumer<RestError> errorHandler;\n{\n\n/**\n * Make a new RestService call.\n *\n * @param operation RestOperation for call Encapsulates individual argument calls.\n * @param <Req>     Type of the payload being sent.\n * @param <Resp>    Type of the response being returned.\n */\nprotected <Req, Resp> void restServiceRequest(RestOperation<Req, Resp> operation);"),a.Qb(),a.Ob(),a.Ob(),a.Kb(66,"hr"),a.Pb(67,"p"),a.zc(68," Let's create a simple service called "),a.Pb(69,"code",0),a.zc(70,"CloudServicesStatus"),a.Ob(),a.zc(71," that calls a remote API via the "),a.Pb(72,"code",0),a.zc(73,"RestService"),a.Ob(),a.zc(74," to check the status of VMware Cloud Services as an example.\n"),a.Ob(),a.Pb(75,"h3"),a.zc(76,"Java VMWCloudServicesStatus"),a.Ob(),a.Pb(77,"pre",2),a.Pb(78,"code",3),a.Jb(),a.zc(79,'package samples.rest;\n\nimport com.vmware.transport.bridge.Request;\nimport com.vmware.transport.bridge.Response;\nimport com.vmware.transport.bus.model.Message;\nimport com.vmware.transport.core.AbstractService;\nimport com.vmware.transport.core.error.RestError;\nimport com.vmware.transport.core.model.RestOperation;\nimport com.vmware.transport.core.model.RestServiceResponse;\nimport com.vmware.transport.core.util.ClassMapper;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.stereotype.Component;\n\nimport java.net.URI;\nimport java.util.UUID;\n\n/**\n * Sample service that makes calls to VMW Cloud Services status API.\n */\n@Component\npublic class VMWCloudServiceStatus extends AbstractService<Request<String>, Response<CloudServicesStatusResponse>> {\n\n    VMCCloudServiceStatus() {\n        super("services-CloudServiceStatus");\n    }\n\n    @Override\n    protected void handleServiceRequest(Request<String> request, Message busMessage) throws Exception {\n\n        // there is only a single operation for this service. We can ignore all requests and auto run our\n        // one request handler.\n        this.handleCloudServiceStatusRequest(request);\n    }\n\n    private void handleCloudServiceStatusRequest(Request req) throws Exception {\n\n        // create a rest call for cloud services.\n        super.restServiceRequest(\n                UUID.randomUUID(),\n                new URI("https://status.vmware-services.io/api/v2/status.json"),\n                HttpMethod.GET,\n                null, null,\n                "samples.rest.CloudServicesStatusResponse",\n                (Response<CloudServicesStatusResponse> resp) -> {\n                    this.sendResponse(resp, req.getId(), req.getTargetUser());\n                },\n                (Response<RestError> error) -> {\n                    this.sendError(error, req.getId());\n                }\n        );\n\n    }\n}'),a.Qb(),a.Ob(),a.Ob(),a.Pb(80,"h3"),a.zc(81,"\ud83d\udc49 No more CORS Issues! \ud83d\udc48"),a.Ob(),a.Pb(82,"p"),a.zc(83," You can call any API you want now, without having to worry about CORS.\n"),a.Ob(),a.Pb(84,"h3"),a.zc(85,"What does the UI Component look like?"),a.Ob(),a.Pb(86,"p"),a.zc(87," If you have been following along with the TypeScript Examples, this should look pretty familiar now.\n"),a.Ob(),a.Pb(88,"h3"),a.zc(89,"Angular CloudServicesApiComponent "),a.Ob(),a.Pb(90,"pre",2),a.Pb(91,"code",3),a.Jb(),a.zc(92,"import { Component, OnDestroy, OnInit } from '@angular/core';\nimport { ClrLoadingState } from '@clr/angular';\nimport { APIResponse } from '@vmw/transport';\nimport { GeneralUtil } from '@vmw/transport/util/util';\nimport { FabricConnectionState } from '@vmw/transport/fabric.api';\nimport { CloudServicesStatusResponse } from './cloud-services.models';\n\n@Component({\n    selector: 'cloudapi-service-component',\n    template: `\n        <div *ngIf=\"connected\">\n            <section>\n                <button [clrLoading]=\"requestLoading\" class=\"btn btn-primary-outline btn-sm\" (click)=\"makeRequest()\">\n                    Request Cloud Services Status\n                </button>\n            </section>\n            <div *ngIf=\"response\">\n                <table class=\"table left table-verticaltable-compact\">\n                    <tbody>\n                    <tr>\n                        <th>Status ID</th>\n                        <td>{{response.page.id}}</td>\n                    </tr>\n                    <tr>\n                        <th>Name</th>\n                        <td>{{response.page.name}}</td>\n                    </tr>\n                    <tr>\n                        <th>Timezone</th>\n                        <td>{{response.page.time_zone}}</td>\n                    </tr>\n                    <tr>\n                        <th>Last Updated</th>\n                        <td>{{response.page.updated_at}}</td>\n                    </tr>\n                    <tr>\n                        <th>Fetched From</th>\n                        <td>{{response.page.url}}</td>\n                    </tr>\n                    <tr>\n                        <th>Indicator</th>\n                        <td>{{response.status.indicator}}</td>\n                    </tr>\n                    <tr>\n                        <th>Service Status</th>\n                        <td>{{response.status.description}}</td>\n                    </tr>\n                    </tbody>\n                </table>\n            </div>\n        </div>\n        <strong *ngIf=\"!connected\">Not connected to fabric, connect to run this code</strong>`\n})\nexport class CloudServicesApiComponent extends AbstractBase implements OnInit, OnDestroy {\n\n    public response: CloudServicesStatusResponse;\n    requestLoading: ClrLoadingState = ClrLoadingState.DEFAULT;\n\n    constructor() {\n        super('CloudServicesApiComponent');\n    }\n\n    ngOnDestroy() {\n        // stop channel from being extended to fabric.\n        this.bus.markChannelAsLocal('services-CloudServiceStatus');\n    }\n\n    ngOnInit(): void {\n        // extend channel to fabric.\n        this.bus.markChannelAsGalactic('services-CloudServiceStatus');\n    }\n\n    private makeRequest() {\n        // show state on the button\n        this.requestLoading = ClrLoadingState.LOADING;\n\n        const request = this.fabric.generateFabricRequest('');\n\n        // make request.\n        this.bus.requestOnceWithId(GeneralUtil.genUUIDShort(), 'services-CloudServiceStatus', request)\n            .handle((response: APIResponse<CloudServicesStatusResponse>) => {\n                this.response = response.payload;\n                this.requestLoading = ClrLoadingState.DEFAULT;\n            });\n    }\n}\n"),a.Qb(),a.Ob(),a.Ob(),a.Kb(93,"hr"),a.Pb(94,"a",4),a.zc(95,"Next Steps: Using Abstractions"),a.Ob())},directives:[s.b],styles:[""]}),e})()},{path:"abstractions",component:(()=>{class e{constructor(e){this.highlightService=e,this.highlighted=!1}ngOnInit(){}ngAfterViewChecked(){this.highlighted||(this.highlightService.highlightAll(),this.highlighted=!0)}}return e.\u0275fac=function(n){return new(n||e)(a.Ib(m.a))},e.\u0275cmp=a.Cb({type:e,selectors:[["transport-abstractions"]],decls:85,vars:0,consts:[[1,"clr-code"],["id","abstractcore"],[1,"emphasis"],[1,"code"],[1,"language-java"],["href","https://github.com/vmware/transport-java/blob/master/java/src/main/com/vmware/transport/core/AbstractBase.java","target","_blank"],["id","abstractservice"],[1,"language-typescript"]],template:function(e,n){1&e&&(a.Pb(0,"h1"),a.zc(1,"Accessing the bus and features via class Abstractions (Java)"),a.Ob(),a.Pb(2,"p"),a.zc(3," In the Java version of the Transport, there are currently only two abstractions available. "),a.Pb(4,"code",0),a.zc(5,"AbstractBase"),a.Ob(),a.zc(6," and "),a.Pb(7,"code",0),a.zc(8,"AbstractService"),a.Ob(),a.zc(9," (which extends from "),a.Pb(10,"code",0),a.zc(11,"AbstractBase"),a.Ob(),a.zc(12,")\n"),a.Ob(),a.Pb(13,"p"),a.zc(14," Extending your classes from these abstractions is pretty important if you want a clean, consistent design in your app.\n"),a.Ob(),a.Kb(15,"hr"),a.Pb(16,"h3",1),a.zc(17,"Using "),a.Pb(18,"code",0),a.zc(19,"AbstractBase"),a.Ob(),a.zc(20," - "),a.Pb(21,"span",2),a.zc(22,"Base class for bus enabled classes"),a.Ob(),a.Ob(),a.Pb(23,"p"),a.Pb(24,"code",0),a.zc(25,"AbstractBase"),a.Ob(),a.zc(26," provides access to the event bus and logging.\n"),a.Ob(),a.Pb(27,"pre",3),a.Pb(28,"code",4),a.Jb(),a.zc(29,"import com.vmware.transport.core.AbstractBase;\n\n@Component\npublic class MyClass extends AbstractBase {\n    // .. regular Java stuff goes here.\n}"),a.Qb(),a.Ob(),a.Ob(),a.Pb(30,"p"),a.Pb(31,"code",0),a.zc(32,"AbstractBase"),a.Ob(),a.zc(33," is actually quite basic, You can see the code at: "),a.Pb(34,"a",5),a.zc(35," https://github.com/vmware/transport-java/blob/master/java/src/main/com/vmware/transport/core/AbstractBase.java "),a.Ob(),a.Ob(),a.Pb(36,"p"),a.zc(37," There is a single required interface method that you need to implement in order to use "),a.Pb(38,"code",0),a.zc(39,"AbstractBase"),a.Ob(),a.zc(40,". This interface method is "),a.Pb(41,"code",0),a.zc(42,"initialize()"),a.Ob(),a.zc(43,". This is your kick off / boot method, to do what ever you need to.\n"),a.Ob(),a.Pb(44,"pre",3),a.Pb(45,"code",4),a.Jb(),a.zc(46,"import com.vmware.transport.core.AbstractBase;\n\n@Component\npublic class MyClass extends AbstractBase {\n    public void initialize() {\n        // .. kick off your stuff here.\n    }\n}"),a.Qb(),a.Ob(),a.Ob(),a.Kb(47,"hr"),a.Pb(48,"h3",6),a.zc(49,"Using "),a.Pb(50,"code",0),a.zc(51,"AbstractService<ReqT, RespT>"),a.Ob(),a.zc(52," - "),a.Pb(53,"span",2),a.zc(54,"For services"),a.Ob(),a.Ob(),a.Pb(55,"p"),a.Pb(56,"code",0),a.zc(57,"AbstractService"),a.Ob(),a.zc(58," allows you to build services that can respond to requests via the distributed bus via Galactic Channels.\n"),a.Ob(),a.Pb(59,"p"),a.zc(60," If you want to build custom services that perform any kind of complex business logic, or call APIs.. and you want to make them available to any UI or CLI that is operating over the fabric, then this is the class for you!\n"),a.Ob(),a.Pb(61,"p"),a.zc(62," The two generic params are the Request type and Response type of what your class is expecting to receive. The request comes from the consumer, the response is what the service returns to the consumer (as the service is the producer).\n"),a.Ob(),a.Pb(63,"p"),a.zc(64," Let's create a sample service called "),a.Pb(65,"strong"),a.zc(66,"CalendarService"),a.Ob(),a.zc(67," that simply returns a date or time. This is a very simple example of a service that uses "),a.Pb(68,"code",0),a.zc(69,"AbstractService"),a.Ob(),a.zc(70,".\n"),a.Ob(),a.Pb(71,"h3"),a.zc(72,"Java CalendarService"),a.Ob(),a.Pb(73,"pre",3),a.Pb(74,"code",4),a.Jb(),a.zc(75,'package samples;\n\nimport com.vmware.transport.bridge.Request;\nimport com.vmware.transport.bridge.Response;\nimport com.vmware.transport.bus.model.Message;\nimport com.vmware.transport.core.AbstractService;\nimport org.springframework.stereotype.Component;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.GregorianCalendar;\n\n@Component\npublic class CalendarService extends AbstractService<Request<String>, Response<String>> {\n\n    // define the channel the service operates on,.\n    public static final String Channel = "calendar-service";\n\n    CalendarService() {\n        super(CalendarService.Channel);\n    }\n\n    // handle service request.\n    protected void handleServiceRequest(Request request, Message busMessage) {\n\n        // which command/request shall we run?\n        switch(request.getRequest()) {\n            case SampleCommand.Date:\n                handleDate(request);\n                break;\n\n            case SampleCommand.Time:\n                handleTime(request);\n                break;\n\n            default:\n                this.handleUnknownRequest(request);\n        }\n    }\n\n    private String formatCalendar(String format) {\n        Calendar calendar = GregorianCalendar.getInstance();\n        SimpleDateFormat fmt = new SimpleDateFormat(format);\n        return fmt.format(calendar.getTime());\n    }\n\n    private void handleTime(Request request) {\n        Response<String> response = new Response<>(request.getId(), formatCalendar("hh:mm:ss a"));\n        this.sendResponse(response, request.getId(), request.getTargetUser());\n    }\n\n    private void handleDate(Request request) {\n        Response<String> response = new Response<>(request.getId(), formatCalendar("yyyy-MM-dd"));\n        this.sendResponse(response, request.getId(), request.getTargetUser());\n    }\n}\n\nabstract class SampleCommand {\n    static final String Time = "time";\n    static final String Date = "date";\n}'),a.Qb(),a.Ob(),a.Ob(),a.Pb(76,"h3"),a.zc(77,"How would I call CalendarService from a UI?"),a.Ob(),a.Pb(78,"p"),a.zc(79," It's still pretty simple. The Demo component above looks like this:\n"),a.Ob(),a.Pb(80,"h3"),a.zc(81,"Angular CalendarComponent"),a.Ob(),a.Pb(82,"pre",3),a.Pb(83,"code",7),a.Jb(),a.zc(84,'import { ChangeDetectorRef, Component, OnDestroy, OnInit } from \'@angular/core\';\nimport { ClrLoadingState } from \'@clr/angular\';\nimport { APIResponse, AbstractBase } from \'@vmw/transport\';\nimport { GeneralUtil } from \'@vmw/transport/util/util\';\nimport { FabricConnectionState } from \'@vmw/transport/fabric.api\';\n\n@Component({\n    selector: \'calendar-service-component\',\n    template: `\n        <div class="clr-row" *ngIf="connected">\n            <div class="clr-col-6">\n                <button [clrLoading]="requestLoading" class="btn btn-primary-outline btn-sm" (click)="requestTime()">\n                    Request Time\n                </button>\n                <button [clrLoading]="requestLoading" class="btn btn-primary-outline btn-sm" (click)="requestDate()">\n                    Request Date\n                </button>\n                <button [clrLoading]="requestLoading" class="btn btn-primary-outline btn-sm" (click)="unknownCommand()">\n                    Send Invalid Command\n                </button>\n            </div>\n            <div class="clr-col-6" *ngIf="item">\n                Fabric Calendar Service Response: <span class="emphasis">{{item}}</span>\n            </div>\n        </div>`\n})\nexport class CalendarServiceComponent extends AbstractBase implements OnInit, OnDestroy {\n\n    requestLoading: ClrLoadingState = ClrLoadingState.DEFAULT;\n    public item: string;\n\n    constructor() {\n        super(\'CalendarServiceComponent\');\n    }\n\n    ngOnDestroy() {\n        // stop channel from being extended to fabric.\n        this.bus.markChannelAsLocal(\'calendar-service\');\n    }\n\n    ngOnInit(): void {\n        // extend channel to fabric.\n        this.bus.markChannelAsGalactic(\'calendar-service\');\n    }\n\n    private makeRequest(command: string) {\n        // show state on the button\n        this.requestLoading = ClrLoadingState.LOADING;\n        const request = this.fabric.generateFabricRequest(command);\n\n        this.bus.requestOnceWithId(GeneralUtil.genUUIDShort(), \'calendar-service\', request)\n            .handle((response: APIResponse<string>) => {\n                this.item = response.payload;\n                this.requestLoading = ClrLoadingState.DEFAULT;\n            });\n    }\n\n    requestTime(): void {\n        this.makeRequest(\'time\');\n    }\n\n    requestDate(): void {\n        this.makeRequest(\'date\');\n    }\n\n    unknownCommand(): void {\n        this.makeRequest(\'invalid\');\n    }\n}\n'),a.Qb(),a.Ob(),a.Ob())},styles:[""]}),e})()}]}];let S=(()=>{class e{}return e.\u0275mod=a.Gb({type:e}),e.\u0275inj=a.Fb({factory:function(n){return new(n||e)},imports:[[s.c.forChild(w)],s.c]}),e})();var k=t("PCNd");let C=(()=>{class e{}return e.\u0275mod=a.Gb({type:e}),e.\u0275inj=a.Fb({factory:function(n){return new(n||e)},imports:[[r.c,k.a,r.c,o.a,S]]}),e})()}}]);